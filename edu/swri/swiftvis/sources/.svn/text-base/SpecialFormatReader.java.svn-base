/* Generated by Together */

package edu.swri.swiftvis.sources;

import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.EOFException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;

import edu.swri.swiftvis.DataElement;
import edu.swri.swiftvis.util.BinaryInput;
import edu.swri.swiftvis.util.TextReader;

/**
* The purpose of this class is to facilitate the reading of special format
* files using the general data source object.  The most significant part of
* the construction of this object is the format string that is passed in.  The
* format of this string varies slightly between the text and binary files, but
* it generally the same.  The string is made from one of more lines each of
* which has one or more tokens on it.  The tokens can be grouped by curly
* braces as well.
*
* Tokens come in the following flavors: stor=type, stor=#, type, or {#|stor tokens}.
* In this, stor can be one of three possible things.  It can be p[#] for a
* parameter, v[#] for a value, or a variable name.  A type begins with an i, r,
* or s and can be optionally followed by the size descriptors that are used for
* binary format files to give i*2, i*4, r*4, r*8, r*x4, or r*x8.  The i is for
* an integer, r is for a real, and s is for a string.  The number
* tells how many bytes it is if it is a binary file.  Also, the x signifies that
* it uses the xdr format.  A j can be placed after the * to signify that the reading
* should be done with Java binary reads.  This is generally only correct if the file was
* written by Java.  If only the type is provided, the value is read and thrown away.
* Strings can only be thrown away at this point.  The use of variables is typically
* for integers only and it specifies how many times a subgrouping is supposed
* to be read.  To allow reading multiple values or parameters of the same type
* the special syntax v[1..100]=type is also supported.  This will read in
* 100 of the given type and put them into values 1 through 100.
*
* If v[#] or p[#] is used with an =s to read in a string, that string is set
* to be the description of that column of values or parameters in the data set.
* This can be handy if you have a header line in the file.  See below how to deal
* with reading only one header.
*
* The variables and curly braces are used in conjunction to allow you to read
* in a number of elements that isn't known beforehand, but is stored in the
* file itself.  It can also be used as shorthand when the number to be read in
* is known beforehand.  An example would be n=i {n v[0..5]=r}.  This will
* read in an integer that tells it how many elements to read where each element
* has 6 values in it.  An element is returned every time the parsing gets to
* the closing of a maximally deep curly brace.  Curly braces can be nested though
* doing so represents 2-D data which this tool is currently not ideally suited
* for dealing with.  Reading values between one close curly brace and a second
* close curly brace will produce unspecified results.  Using a number after the
* open curly brace instead of a variable will always read that number of records.
* parameters can also be used there.  If a value is used, it will be converted
* to an integer for that purpose.  You can also put in a # to say that the given
* grouping should be read until the end of the file.  This is a good way to
* skip header lines.  You read in the strings in the header then follow that with
* a group that will be read to the end of the file.  Variable names should
* only include characters and numbers.
*
* Lastly, you can store numeric values directly into parameters or values by
* having a token of the format p[#]=# or v[#]=#.  So if all elements read at
* a certain point should have a first parameter of 1 you might use p[0]=1.
*
* Here is a more complex example of how something like the original SWIFT binary
* files migh be specified in this format if written in real*4 format.  This is similar to
* what happens in the BinaryPositionData class only it would require reading one fewer
* bodies which this class currently does not support.
*
* v[0]=r*4 nbod=i*2 ntp=i*2
* p[0]=0
* {nbod p[1]=i*2 v[1..6]=r*4}
* p[0]=1
* {ntp p[1]=i*2 v[1..6]=r*4}
*
* Note the use of stored constants to signify massive bodies or test particles.
* Also note that the time value read in at the very beginning is remembered
* all the way through until it is read again many elements later.
* This will be read repeatedly until the end of the file is reached.  To read
* a smaller number, the entire string could be put in curly braces with a constant
* specified at the beginning.  So this would try to read only 100 entries or
* stop at the end of the file if it was shorter than that.  This is the one case
* where nesting curly braces can make some sense.
* 
* {100 v[0]=r*4 nbod=i*2 ntp=i*2
* p[0]=0
* {nbod p[1]=i*2 v[1..6]=r*4}
* 1=p[0]
* {ntp p[1]=i*2 v[1..6]=r*4}}
*
* White spaces are used to separate tokens but are otherwise ignored.  The
* format modifiers (*2, *4, etc.) are ignored for text input.  For binary
* files the defaults are i*2 and r*4 as those are what are generally used by
* SWIFT.
*
* Note that Fortran binary files typically have headers and footers around each
* record.  Those are four by ints that tell how many bytes are in the record.
* So to make the above actually work with a binary file produced by SWIFT (which
* you don't need to do since we provide that tool) you would need to add in
* extra reads of 4 byte integers as follows.
*
* i*4 v[0]=r*4 nbod=i*2 ntp=i*2 i*4
* p[0]=0
* {nbod i*4 p[1]=i*2 v[1..6]=r*4 i*4}
* p[0]=1
* {ntp i*4 p[1]=i*2 v[1..6]=r*4 i*4}
*
* To figure out where the extra integers will be written you have to see the
* code that was used to write it.  Binary files written in C/C++ will not have
* this.
**/
public class SpecialFormatReader implements java.io.Serializable {
    public SpecialFormatReader(GeneralData gd,File f,String fs,boolean bin) throws IOException {
        data=gd;
        file=f;
        format=fs;
        useBinary=bin;
        root=new BracketToken(format);
        params=new int[maxParameter+1];
        values=new float[maxValue+1];
        resetStream();
    }

    public void resetStream() throws IOException {
        if(useBinary) {
        	if(bis!=null) {
        		bis.close();
        	}
			bis=new BinaryInput(new DataInputStream(new BufferedInputStream(new FileInputStream(file))));
        } else {
        	if(tReader!=null) {
        		tReader.close();
        	} 
			tReader=new TextReader(new FileReader(file));
        }
        nextToRead=root;
        root.reset();
    }

    public DataElement readNextElement() throws IOException {
    	if((useBinary && bis==null) || (!useBinary && tReader==null)) data.specialFormatReset();
        if(nextToRead==null) throw new EOFException("Formatted reading complete.");
        nextToRead.process();
        return new DataElement(params,values);
    }

    private int readInt(int type) throws IOException {
        if(useBinary) {
            if(type==INT4) {
                return bis.readInt4();
            } else if(type==JAVA_INT2) {
            	return bis.readJavaInt2();
			} else if(type==JAVA_INT4) {
				return bis.readJavaInt4();
            } else {
                return bis.readInt2();
            }
        } else {
            return tReader.readInt();
        }
    }

    private double readReal(int type) throws IOException {
        if(useBinary) {
            if(type==REAL8) {
                return bis.readReal8();
            } else if(type==XDR8) {
                return bis.readXDR8();
            } else if(type==XDR4) {
                return bis.readXDR4();
			} else if(type==JAVA_REAL4) {
				return bis.readJavaReal4();
			} else if(type==JAVA_REAL8) {
				return bis.readJavaReal8();
            } else {
                return bis.readReal4();
            }
        } else {
            return tReader.readDouble();
        }
    }

    private String readString() throws IOException {
        if(useBinary) {
            return "";
        } else {
            return tReader.readWord();
        }
    }

    /**
     * Decipher what type a store should be and return the proper object type.
     * Possibilities are v[#], v[#..#], p[#], p[#..#], and variable names which
     * can not have brackets in them.
     */
    private Store parseStore(String str) {
        if(str.indexOf('[')<0) {
            return new VariableStore(str);
        } else {
            if((str.startsWith("v[") || str.startsWith("p[")) && str.endsWith("]")) {
                int dotsLoc=str.indexOf("..");
                if(dotsLoc<0) {
                    int index=Integer.parseInt(str.substring(2,str.length()-1));
                    if(str.charAt(0)=='v') {
                        return new ValueStore(index,index);
                    } else {
                        return new ParameterStore(index,index);
                    }
                } else {
                    int minIndex=Integer.parseInt(str.substring(2,dotsLoc));
                    int maxIndex=Integer.parseInt(str.substring(dotsLoc+2,str.length()-1));
                    if(str.charAt(0)=='v') {
                        return new ValueStore(minIndex,maxIndex);
                    } else {
                        return new ParameterStore(minIndex,maxIndex);
                    }
                }
            }
        }
        throw new IllegalArgumentException("Parse error: got down to ("+str+") as a store.");
    }

    private static final int INT2=0;
    private static final int INT4=1;
	private static final int JAVA_INT2=2;
	private static final int JAVA_INT4=3;
    private static final int REAL4=0;
    private static final int REAL8=1;
    private static final int XDR4=2;
    private static final int XDR8=3;
	private static final int JAVA_REAL4=4;
	private static final int JAVA_REAL8=5;

    /**
     * 
     * @uml.property name="data"
     * @uml.associationEnd multiplicity="(1 1)" inverse="sfr:edu.swri.swiftvis.sources.GeneralData"
     */
    private GeneralData data;

    private File file;
    private String format;
    private boolean useBinary;
    private transient int maxParameter=-1;
    private transient int maxValue=-1;
    private int[] params;
    private float[] values;

    /**
     * 
     * @uml.property name="root"
     * @uml.associationEnd multiplicity="(1 1)"
     */
    private Token root;

    /**
     * 
     * @uml.property name="nextToRead"
     * @uml.associationEnd multiplicity="(1 1)"
     */
    private Token nextToRead;

    /**
     * 
     * @uml.property name="bis"
     * @uml.associationEnd multiplicity="(1 1)"
     */
    private transient BinaryInput bis;

    /**
     * 
     * @uml.property name="tReader"
     * @uml.associationEnd multiplicity="(1 1)"
     */
    private transient TextReader tReader;

    private static final long serialVersionUID=347625734782323356l;

    private interface Token extends java.io.Serializable {
        /**
         * This function will start at the token it is called on processing it
         * in whatever way is needed.  When this function returns, a full element
         * has been read and nextToRead is set to the 
         */
		void process() throws IOException;
		
		/**
		 * Returns the store used by this token.
		 * @return The store that things should go in for this token.
		 */
        Store getStore();
        
        /**
         * This can be used to make sure that a token starts "processing" at
         * the beginning.  Currently this is only really needed for the BracketToken.
         */
        void reset();
    }

    private class BracketToken implements Token {
        public BracketToken(String str) {
            parent=null;
            childTokens=new ArrayList<Token>();
            if(str.charAt(0)!='{') {
                str="{# "+str+"}";
            }
            parseString(str);
        }

        public BracketToken(BracketToken p,String str) {
            parent=p;
            childTokens=new ArrayList<Token>();
            parseString(str);
        }

        public void process() throws IOException {
            while(currentChild<childTokens.size()) {
                Token cur=childTokens.get(currentChild);
                currentChild++;
                if(cur instanceof BracketToken) {
                    BracketToken bt=(BracketToken)cur;
                    bt.numReads=0;
                    bt.currentChild=0;
                    bt.process();
                    return;
                } else {
                    cur.process();
                }
            }
            checkForNextToRead();
        }

        public Store getStore() {
            return null;
        }

		public void reset() {
			currentChild=0;
			numReads=0;
		}
		
        private void parseString(String str) {
            System.out.println("Parsing bracket token: "+str);
            if(str.charAt(0)=='{') {
                int i;
                for(i=str.length()-1; str.charAt(i)!='}'; i--);
                str=str.substring(1,i);

                // Deal with stop criteria
                for(i=0; str.charAt(i)>32; i++);
                String stopSymbol=str.substring(0,i);
                System.out.println("Stop Symbol="+stopSymbol+" i="+i+" char="+str.charAt(i)+" "+(int)str.charAt(i));
                if(stopSymbol.equals("#")) {
                    stopType=NO_STOP;
                } else if(stopSymbol.indexOf('[')>=0) {
                    stopType=STORE_STOP;
                    stopData=Integer.parseInt(stopSymbol.substring(2,stopSymbol.length()-1));
                    if(stopSymbol.startsWith("v[")) {
						stopStore=new ValueStore(stopData,stopData);
                    } else if(stopSymbol.startsWith("p[")) {
						stopStore=new ParameterStore(stopData,stopData);
                    }
                } else {
                    try {
                        stopData=Integer.parseInt(stopSymbol);
                        stopType=CONST_STOP;
                    } catch(NumberFormatException e) {
                        // find variable in scope
	                    stopType=STORE_STOP;
                        stopStore=parent.findVariableStore(stopSymbol);
                    }
                }

                // Parse child tokens
                while(str.charAt(i)<=32) i++;
                while(i<str.length()) {
                    Token child;
                    int start=i;
                    if(str.charAt(i)=='{') {
	                    while(str.charAt(i)!='}') i++;
	                    int end=i;
                        child=new BracketToken(this,str.substring(start,end+1));
                        i++;
                    } else {
	                    while(i<str.length() && str.charAt(i)>32 && str.charAt(i)!='}') i++;
                        String tokenStr=str.substring(start,i);
                        System.out.println("start="+start+" i="+i+" Token string is: "+tokenStr);
                        if(tokenStr.endsWith("i") || tokenStr.endsWith("i*2") || tokenStr.endsWith("i*4")
						|| tokenStr.endsWith("i*j2") || tokenStr.endsWith("i*j4")) {
                            child=new IntToken(tokenStr);
                        } else if(tokenStr.endsWith("r") || tokenStr.endsWith("r*4") || tokenStr.endsWith("r*8")
                        || tokenStr.endsWith("r*x4") || tokenStr.endsWith("r*x8")
                        || tokenStr.endsWith("r*j4") || tokenStr.endsWith("r*j8")) {
                            child=new RealToken(tokenStr);
                        } else if(tokenStr.endsWith("s")) {
                            child=new StringToken(tokenStr);
                        } else {
                            child=new ConstantToken(tokenStr);
                        }
	                }
                    childTokens.add(child);
                    while(i<str.length() && str.charAt(i)<=32) i++;
                }
            }
        }

        private Store findVariableStore(String name) {
            for(int i=childTokens.size()-1; i>=0; i--) {
                Store store=childTokens.get(i).getStore();
                if(store!=null) {
                    if(store.matchName(name)) return store;
                }
            }
            if(parent!=null) return parent.findVariableStore(name);
            throw new IllegalArgumentException("Variable "+name+" not found in scope prior to use.");
        }

        private int stopCount() {
            if(stopType==NO_STOP) return Integer.MAX_VALUE;
            if(stopType==CONST_STOP) return stopData;
            if(stopType==STORE_STOP) return stopStore.getCountValue();
            throw new IllegalArgumentException("Processing a bracket with bad stop type.");
        }

        private void checkForNextToRead() {
			if(currentChild>=childTokens.size()) {
	            numReads++;
	            currentChild=0;
				if(numReads<stopCount()) {
					nextToRead=this;
				} else {
                    if(parent!=null) {
	                    parent.checkForNextToRead();
                    } else {
                        nextToRead=null;  // Completely done.
                    }
				}
            } else {
                nextToRead=this;
            }
        }

        /**
         * 
         * @uml.property name="parent"
         * @uml.associationEnd multiplicity="(0 1)"
         */
        private BracketToken parent;

        private ArrayList<Token> childTokens;
        private int stopType;
        private int stopData;

        /**
         * 
         * @uml.property name="stopStore"
         * @uml.associationEnd multiplicity="(0 1)"
         */
        private Store stopStore;

        private int numReads=0;  // current state.
        private int currentChild=0;

		private static final int NO_STOP=0;
		private static final int CONST_STOP=1;
		private static final int STORE_STOP=2;
        private static final long serialVersionUID=34672375608946l;
    }

    private class IntToken implements Token {
        public IntToken(String str) {
            int equalsIndex=str.indexOf('=');
            if(str.endsWith("i") || str.endsWith("i*2")) type=INT2;
            else if(str.endsWith("i*4")) type=INT4;
			else if(str.endsWith("i*j2")) type=JAVA_INT2;
			else if(str.endsWith("i*j4")) type=JAVA_INT4;
            if(equalsIndex>0) {
                store=parseStore(str.substring(0,equalsIndex));
            }
        }

        public void process() throws IOException {
            if(store!=null) {
                for(int i=0; i<store.getNumRepresented(); i++) {
		            int val=readInt(type);
        	        store.storeInt(val,i);
	            }
            } else readInt(type);
        }

        /**
         * 
         * @uml.property name="store"
         */
        public Store getStore() {
            return store;
        }


		public void reset() { }
		
        private int type;

        /**
         * 
         * @uml.property name="store"
         * @uml.associationEnd multiplicity="(0 1)"
         */
        private Store store;
        private static final long serialVersionUID=734685763475l;
    }

    private class RealToken implements Token {
        public RealToken(String str) {
            int equalsIndex=str.indexOf('=');
            if(str.endsWith("r") || str.endsWith("r*4")) type=REAL4;
            else if(str.endsWith("r*8")) type=REAL8;
            else if(str.endsWith("r*x4")) type=XDR4;
            else if(str.endsWith("r*x8")) type=XDR8;
			else if(str.endsWith("r*j4")) type=JAVA_REAL4;
			else if(str.endsWith("r*j8")) type=JAVA_REAL8;
            if(equalsIndex>0) {
                store=parseStore(str.substring(0,equalsIndex));
            }
        }

        public void process() throws IOException {
            if(store!=null) {
                for(int i=0; i<store.getNumRepresented(); i++) {
		            float val=(float)readReal(type);
        	        store.storeReal(val,i);
	            }
            } else readReal(type);
        }

        /**
         * 
         * @uml.property name="store"
         */
        public Store getStore() {
            return store;
        }


		public void reset() { }

        private int type;

        /**
         * 
         * @uml.property name="store"
         * @uml.associationEnd multiplicity="(0 1)"
         */
        private Store store;
        private static final long serialVersionUID=854709873655l;
    }

    private class StringToken implements Token {
        public StringToken(String str) {
            int equalsIndex=str.indexOf('=');
            if(equalsIndex>0) {
                store=parseStore(str.substring(0,equalsIndex));
            }
        }

        public void process() throws IOException {
            if(store!=null) {
                for(int i=0; i<store.getNumRepresented(); i++) {
		            String val=readString();
        	        store.storeString(val,i);
	            }
            } else readString();
        }

        /**
         * 
         * @uml.property name="store"
         */
        public Store getStore() {
            return store;
        }


		public void reset() { }

        /**
         * 
         * @uml.property name="store"
         * @uml.associationEnd multiplicity="(0 1)"
         */
        private Store store;
        private static final long serialVersionUID=59238670298346l;
    }

    private class ConstantToken implements Token {
        public ConstantToken(String str) {
            int equalsIndex=str.indexOf('=');
            if(equalsIndex<0) throw new IllegalArgumentException("Defaulted to constant token with "+str);
            else {
                store=parseStore(str.substring(0,equalsIndex));
                value=Float.parseFloat(str.substring(equalsIndex+1));
            }
        }

        public void process() throws IOException {
            if(store!=null) {
                for(int i=0; i<store.getNumRepresented(); i++) {
        	        store.storeReal(value,i);
	            }
            }
        }

        /**
         * 
         * @uml.property name="store"
         */
        public Store getStore() {
            return store;
        }


		public void reset() { }

        private float value;

        /**
         * 
         * @uml.property name="store"
         * @uml.associationEnd multiplicity="(0 1)"
         */
        private Store store;
        private static final long serialVersionUID=76932487823823l;
    }

    private interface Store extends java.io.Serializable {
        boolean matchName(String name);
        void storeInt(int val,int count);
        void storeReal(float val,int count);
        void storeString(String val,int count);
        int getNumRepresented();
        int getCountValue();
    }

    private class ValueStore implements Store {
        public ValueStore(int mini,int maxi) {
            min=mini; max=maxi;
            if(max>maxValue) maxValue=max;
        }
        public boolean matchName(String n) { return false; }
        public void storeInt(int val,int count) { values[min+count]=val; }
        public void storeReal(float val,int count) { values[min+count]=val; }
        public void storeString(String val,int count) { data.setValueDescription(min+count,val); }
        public int getNumRepresented() { return max-min+1; }
        public int getCountValue() { return (int)values[min]; }
        private int min;
        private int max;
        private static final long serialVersionUID=84578945884546l;
    }

    private class ParameterStore implements Store {
        public ParameterStore(int mini,int maxi) {
            min=mini; max=maxi;
            if(max>maxParameter) maxParameter=max;
        }
        public boolean matchName(String n) { return false; }
        public void storeInt(int val,int count) { params[min+count]=val; }
        public void storeReal(float val,int count) { params[min+count]=(int)val; }
        public void storeString(String val,int count) { data.setParameterDescription(min+count,val); }
        public int getNumRepresented() { return max-min+1; }
        public int getCountValue() { return params[min]; }
        private int min;
        private int max;
        private static final long serialVersionUID=3473434646777l;
    }

    private static class VariableStore implements Store {
        public VariableStore(String n) { name=n; }
        public boolean matchName(String n) { return n.equals(name); }
        public void storeInt(int v,int count) { val=v; }
        public void storeReal(float v,int count) { val=v; }
        public void storeString(String v,int count) {}
        public int getNumRepresented() { return 1; }
        public int getCountValue() { return (int)val; }
        private String name;
        private float val=0.0f;
        private static final long serialVersionUID=5665329867236l;
    }
}
