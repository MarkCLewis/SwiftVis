/* Generated by Together */

package edu.swri.swiftvis.filters;

import java.awt.*;
import javax.swing.*;

import edu.swri.swiftvis.*;
import edu.swri.swiftvis.util.EditableBoolean;
import edu.swri.swiftvis.util.ReduceLoopBody;
import edu.swri.swiftvis.util.ThreadHandler;

import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;
import java.awt.event.*;

/**
 * This class provides a way for the user to select specific elements
 * from inputs.  It supports multiple inputs for the selection expressions,
 * but only elements from the first input are passed through.  If you want
 * elements strung together in serial you should use a MergeFilter.  If you
 * want them in parallel with elements that have some values from one input
 * and some from others then a FunctionFilter can do the job.
 * 
 * This filter has several "modes" of operation.  The simplest one allows the user
 * to type in a simple boolean expression.  If that expression is true for a
 * given index number then the element with that index from the first input is
 * passed through.  To quickly thin out a SWIFT file with a large number of
 * particles you can use % operator in the expression with the particle number so
 * p[1]%10==0 would only pass through every tenth particle from a SWIFT binary file. 
 * 
 * This is enhanced by working with what we call subsets (taking all
 * elements that have the same value for a certain expression).  You can toggle whether
 * you want to use subsets or groups in a selection.
 * 
 * To see the value of this, let's look at an example of doing a selection based
 * with subsets but not using groups.  You provide an expression like in the simple
 * form as well as a subset expression.  In this case it is not just single
 * elements that are selected.  Instead, all elements for which the provided subset
 * expression match that of any matching element will be taken.  This requires two
 * passes through the data.  First, the subsets that will be used are identified then
 * all the elements in those subsets are selected.  In SWIFT this can be used to
 * select all particles which matched some simple expression at some time during the
 * simulation.  So the subset expression could be p[1] and if we only want particles
 * whose eccentricity was greater than 0.3 the selection expression could be v[2]>0.3.
 * 
 * Sometimes you want the selection to be based on a comparison of one element to
 * another one.  The normal expression model allows you do do this with an offset or
 * using a fixed element to compare to.  Sometimes you want the selection of element to
 * be data driven.  For example, you want to compare all the bodies in a given timestep
 * to one particular body.  To do this we use groups.  For a group to be used, the input
 * data must be sorted by the value you want things grouped by.  In the example of
 * comparing particles at a timestep, the time is what you would want it sorted by.  A
 * group is defined as all elements that have the same value of the sorted expression.
 * A SortFilter can be used to choose different sort orders.  The basic DataFormula class
 * provides functionality for goring grouping.  If you wanted to find instances
 * where a particle was close to Jupiter and Jupiter had a particle ID of -2 then your
 * special element selection would be p[1]=-2.  If the expression doesn't pick a unique
 * element in a group, the first one that satisfies it will be used.  If no elements
 * in a group satisfy it, the entire group is ignored.  The values and parameters for the
 * selected element are significied in the formula with primes (single quotes).  So just
 * comparing the difference between the semimajor axes might look like abs(v[1]-v'[1])<0.1.
 * The subset formula can not involve the selected group member.
 * 
 * If grouping is used without subsets in this case you would only get the elements for
 * particles close to Jupiter at the time they were close to Jupiter.  Combining it with
 * a subset expression of particle ID would select the entire histories of any particles
 * that had close encounters.  If no element in a group matches the selection criteria then
 * the entire group will be ignored.
 * 
 * The selection filter can take more than one input, and formulas can refer to the other inputs.
 * The data in the different inputs needs to be parallel to have meaning though and elements are
 * only selected from the first input.
 **/
public class SelectFilter extends AbstractMultipleSourceFilter {
    public SelectFilter() {
        formula=new BooleanFormula("1=0");
        subsetFormula=new DataFormula("v[0]");
    }

    private SelectFilter(SelectFilter c,List<GraphElement> l) {
        super(c,l);
        formula=new BooleanFormula(c.formula);
        subsetFormula=new DataFormula(c.subsetFormula);
        useSubsets=new EditableBoolean(c.useSubsets.getValue());
    }

    public String getDescription(){ return "Selection Filter"; }

    public static String getTypeDescription(){ return "Selection Filter"; }

    protected void setupSpecificPanelProperties(){
        JPanel formPanel=new JPanel(new BorderLayout());
        Box topBox=Box.createVerticalBox();
        JPanel tmpPanel=new JPanel(new BorderLayout());
        tmpPanel.add(new JLabel("Boolean Expression"),BorderLayout.WEST);
        tmpPanel.add(formula.getTextField(null),BorderLayout.CENTER);
        topBox.add(tmpPanel);

        // Subsets
        tmpPanel=new JPanel(new GridLayout(2,1));
        tmpPanel.setBorder(BorderFactory.createTitledBorder("Subsets"));
        tmpPanel.add(useSubsets.getCheckBox("Use Subsets?",null));
        JPanel tmpPanel2=new JPanel(new BorderLayout());
        tmpPanel2.add(new JLabel("Subset Match Expression"),BorderLayout.WEST);
        tmpPanel2.add(subsetFormula.getTextField(null),BorderLayout.CENTER);
        tmpPanel.add(tmpPanel2);
        topBox.add(tmpPanel);

        formPanel.add(topBox,BorderLayout.NORTH);
        JButton button=new JButton("Propagate Changes");
        button.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) { abstractRedoAllElements(); }
        } );
        formPanel.add(button,BorderLayout.SOUTH);
        propPanel.add("Expression",formPanel);
    }

    /**
     * Tells you what a particular parameter is used for.
     */
    public String getParameterDescription(int stream, int which){
        return inputVector.get(0).getParameterDescription(stream,which);
    }

    /**
     * Tells you what a particular value is used for.
     */
    public String getValueDescription(int stream, int which){
        return inputVector.get(0).getValueDescription(stream, which);
    }

    public int getNumParameters(int stream){
        if(inputVector.size()<1) return 0;
        return inputVector.get(0).getNumParameters(stream);
    }

    public int getNumValues(int stream){
        if(inputVector.size()<1) return 0;
        return inputVector.get(0).getNumValues(stream);
    }

    public SelectFilter copy(List<GraphElement> l) {
        return new SelectFilter(this,l);
    }

    protected boolean doingInThreads() {
        return true;
    }

    protected void redoAllElements() {
        formula.clearGroupSelection();
        if(inputVector.size()<1) return;
        sizeDataVectToInputStreams();
        for(int s=0; s<inputVector.get(0).getNumStreams(); ++s) {
            final int ss=s;
            int[] indexBounds=formula.getSafeElementRange(this,s);
            DataFormula.checkRangeSafety(indexBounds,this);

            //  parallel
            if (useSubsets.getValue()) {
                final Hashtable<Double,Integer> subsetValues=new Hashtable<Double,Integer>(10000);
                final DataFormula[] subsets=new DataFormula[ThreadHandler.instance().getNumThreads()];
                final BooleanFormula[] formulas=new BooleanFormula[ThreadHandler.instance().getNumThreads()];
                ReduceLoopBody[] reduceLoops=new ReduceLoopBody[ThreadHandler.instance().getNumThreads()];
                for (int i=0; i<ThreadHandler.instance().getNumThreads(); i++) {
                    final int index=i;
                    subsets[i]=subsetFormula.getParallelCopy();
                    formulas[i]=formula.getParallelCopy();
                    reduceLoops[i]=new ReduceLoopBody() {
                        public void execute(int start, int end) {
                            DataFormula sub=subsets[index];
                            BooleanFormula ff=formulas[index];
                            for (int j=start; j<end; j++) {
                                boolean selected=false;
                                selected=ff.valueOf(SelectFilter.this,ss, j);
                                if(selected) {
                                    subsetValues.put(sub.valueOf(SelectFilter.this,ss, j),j);
                                }
                            }
                        }
                    };
                }
                ThreadHandler.instance().chunkedForLoop(this,indexBounds[0],indexBounds[1],reduceLoops);

                final ArrayList<ArrayList<DataElement>> vects=new ArrayList<ArrayList<DataElement>>();
                for (int i=0; i<ThreadHandler.instance().getNumThreads(); i++) {
                    vects.add(new ArrayList<DataElement>());
                }
                final DataFormula[] sfs=new DataFormula[ThreadHandler.instance().getNumThreads()];
                // create ReduceLoopBody array
                ReduceLoopBody[] loops=new ReduceLoopBody[vects.size()];
                for (int i=0; i<loops.length; i++) {
                    final int index=i;
                    sfs[i]=subsetFormula.getParallelCopy();
                    loops[i]=new ReduceLoopBody() {
                        public void execute(int start, int end) {
                            ArrayList<DataElement> data=vects.get(index);
                            DataFormula sub=sfs[index];
                            for (int j=start; j<end; j++) {
                                Double key=new Double(sub.valueOf(SelectFilter.this,ss,j));
                                if(subsetValues.containsKey(key)) {
                                    data.add(inputVector.get(0).getElement(j,ss));
                                }
                            }
                        }
                    };
                }
                ThreadHandler.instance().chunkedForLoop(this,indexBounds[0],indexBounds[1],loops);
                // merge lists
                int size=0;
                for (int i=0; i<vects.size(); i++) {
                    size+=vects.get(i).size();
                }
                dataVect.get(s).ensureCapacity(size);
                for (int i=0; i<vects.size(); i++) {
                    dataVect.get(s).addAll(vects.get(i));
                }
            } else {
                final ArrayList<ArrayList<DataElement>> vects=new ArrayList<ArrayList<DataElement>>();
                for (int i=0; i<ThreadHandler.instance().getNumThreads(); i++) {
                    vects.add(new ArrayList<DataElement>());
                }
                final BooleanFormula[] forms=new BooleanFormula[ThreadHandler.instance().getNumThreads()];
                // create ReduceLoopBody array
                ReduceLoopBody[] loops=new ReduceLoopBody[vects.size()];
                for (int i=0; i<loops.length; i++) {
                    final int index=i;
                    forms[i]=formula.getParallelCopy();
                    loops[i]=new ReduceLoopBody() {
                        public void execute(int start, int end) {
                            ArrayList<DataElement> data=vects.get(index);
                            BooleanFormula ff=forms[index];
                            for (int j=start; j<end; j++) {
                                boolean selected=false;
                                selected=ff.valueOf(SelectFilter.this,ss,j);
                                if (selected) {
                                    data.add(inputVector.get(0).getElement(j,ss));
                                }
                            }
                        }
                    };
                }
                ThreadHandler.instance().chunkedForLoop(this,indexBounds[0],indexBounds[1],loops);
                // merge lists
                int size=0;
                for (int i=0; i<vects.size(); i++) {
                    size+=vects.get(i).size();
                }
                dataVect.get(s).ensureCapacity(size);
                for (int i=0; i<vects.size(); i++) {
                    dataVect.get(s).addAll(vects.get(i));
                }
            }
        }
    }

    private BooleanFormula formula;

    private EditableBoolean useSubsets=new EditableBoolean(false);

    private DataFormula subsetFormula;

    private static final long serialVersionUID=1469087341467l;
}
