/* Generated by Together */

package edu.swri.swiftvis.util;

import java.io.DataInput;
import java.io.IOException;
import java.io.InputStream;
import java.io.RandomAccessFile;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import edu.swri.swiftvis.OptionsData;

/**
* This class is intended to help other parts of the code read in data that is
* in a FORTRAN, C, or Java binary file.  When using this, keep in mind that FORTRAN writes
* fields with headers and footers that tell you how many bytes are in the
* field.
**/
public class BinaryInput {
    public BinaryInput(DataInput di) {
        wrapped=di;
    }
    
    /**
     * Closes the wrapped file.
     * @throws IOException passes on the exception from the close method.
     */
    public void close() throws IOException {
        if(wrapped instanceof InputStream) {
            ((InputStream)wrapped).close();
        } else {
            ((RandomAccessFile)wrapped).close();
        }
    }

    /**
     * Reads a float in Java binary format.
     * @return The float that was read.
     * @throws IOException This will be thrown if there is a problem reading 4 bytes.
     */
    public double readJavaReal4() throws IOException {
    	return wrapped.readFloat();
    }

    /**
     * Reads a double in Java binary format.
     * @return The double that was read.
     * @throws IOException This will be thrown if there is a problem reading 8 bytes.
     */
	public double readJavaReal8() throws IOException {
		return wrapped.readDouble();
	}

    /**
     * This reads in four bytes and tries to convert them to a floating point value.
     * This method references the options for whether you are reading a big-endian
     * or a little-endian file.
     * @return The float that was read.
     * @throws IOException This is thrown if there is a problem reading 4 bytes.
     */
    public double readReal4() throws IOException {
        return Float.intBitsToFloat(readInt4());
    }

    /**
     * This reads in eight bytes and tries to convert them to a floating point value.
     * This method references the options for whether you are reading a big-endian
     * or a little-endian file.
     * @return The double that was read.
     * @throws IOException This is thrown if there is a problem reading 8 bytes.
     */
    public double readReal8() throws IOException {
        return Double.longBitsToDouble(readInt8());
    }

    /**
     * This reads in a single 4-byte real in XDR format.
     * @return The value that was read.
     * @throws IOException This is thrown if four bytes couldn't be read.
     */
    public double readXDR4() throws IOException {
        return readJavaReal4();
    }

    /**
     * This reads in a single 8-byte real in XDR format.
     * @return The value that was read.
     * @throws IOException This is thrown if eight bytes couldn't be read.
     */
    public double readXDR8() throws IOException {
        return readJavaReal8();
    }

    /**
     * Reads in eight bytes and compiles them to an integer value.  It will change
     * byte order if needed for endianness.
     * @return The integer value that was read.
     * @throws IOException This is thrown if eight bytes couldn't be read.
     */
    public long readInt8() throws IOException {
        long ret=wrapped.readLong();
        if(OptionsData.instance().getLittleEndian()) {
            ret=Long.reverseBytes(ret);
        }
        return ret;
    }

    /**
     * Reads in four bytes and compiles them to an integer value.  It will change
     * byte order if needed for endianness.
     * @return The integer value that was read.
     * @throws IOException This is thrown if four bytes couldn't be read.
     */
    public int readInt4() throws IOException {
        int ret=wrapped.readInt();
        if(OptionsData.instance().getLittleEndian()) {
            ret=Integer.reverseBytes(ret);
        }
        return ret;
    }

    /**
     * Reads in two bytes and compiles them to an integer value.  It will change
     * byte order if needed for endianness.
     * @return The integer value that was read.
     * @throws IOException This is thrown if two bytes couldn't be read.
     */
    public int readInt2() throws IOException {
        short ret=wrapped.readShort();
        if(OptionsData.instance().getLittleEndian()) {
            ret=Short.reverseBytes(ret);
        }
        return ret;
    }

    /**
     * Reads two bytes and converts them to an int according to XDR format.
     * @return The value read.
     * @throws IOException This is thrown if two bytes could not be read.
     */
    public int readIntXDR2() throws IOException {
        return wrapped.readShort();
    }

    /**
     * Reads four bytes and converts them to an int according to XDR format.
     * @return The value read.
     * @throws IOException This is thrown if four bytes could not be read.
     */
    public int readIntXDR4() throws IOException {
        return wrapped.readInt();
    }

    /**
     * Reads eight bytes and converts them to an int according to XDR format.
     * @return The value read.
     * @throws IOException This is thrown if eight bytes could not be read.
     */
    public long readIntXDR8() throws IOException {
        return wrapped.readLong();
    }

    /**
     * Reads four bytes and converts them to an int according to Java format.
     * @return The value read.
     * @throws IOException This is thrown if four bytes could not be read.
     */
    public int readJavaInt4() throws IOException {
		return wrapped.readInt();
	}

    /**
     * Reads two bytes and converts them to an int according to Java format.
     * @return The value read.
     * @throws IOException This is thrown if two bytes could not be read.
     */
	public int readJavaInt2() throws IOException {
		return wrapped.readShort();
	}
    
    /**
     * This reads in C-style string.  That is a null terminated array of chars. 
     * @return A Java string representing the C-string.
     * @throws IOException This will be thrown if there is an exception before a 0 is read in.
     */
    public String readCString() throws IOException {
        StringBuffer buf=new StringBuffer();
        byte b=wrapped.readByte();
        while(b!=0) {
            buf.append((char)b);
            b=wrapped.readByte();
        }
        return buf.toString();
    }

    /**
     * Reads a single byte.
     * @return The byte read.
     * @throws IOException This is thrown if a byte can't be read.
     */
    public byte readByte() throws IOException {
        return wrapped.readByte();
    }
    
    /**
     * Reads a full array of bytes.
     * @param b The byte to read the values into.
     * @throws IOException This will be thrown if b.length bytes can not be read in.
     */
    public void readFully(byte[] b) throws IOException {
        wrapped.readFully(b);
    }
    
    /**
     * This reads a Fortran integer occupying the specified number of characters.
     * @param numDigits The number of character to read in.
     * @return The value of the string read in.
     * @throws IOException This is thrown if the specified number of bytes can't be read.
     */
    public int readFortranInt(int numDigits) throws IOException {
        int ret=0;
        for(int i=0; i<numDigits; ++i) {
            ret=ret*10+(readByte()-'0');
        }
        return ret;
    }

    /**
     * This reads a Fortran string occupying the specified number of characters.
     * @param numDigits The number of character to read in.
     * @return The value of the string read in.
     * @throws IOException This is thrown if the specified number of bytes can't be read.
     */
    public String readFortranString(int numChars) throws IOException {
        byte[] ret=new byte[numChars];
        for(int i=0; i<numChars; ++i) {
            ret[i]=readByte();
        }
        return new String(ret);
    }
    
    /**
     * <p>This method reads in a record from a Fortran binary file.  It will read in
     * the header and footer for the record and verify that they are equal and that
     * the number of bytes read in matches them.</p>
     * <p>The format is specified as a string in a manner similar to that used in
     * general data source.  It should be a space separated list of formats.  The
     * accepted formats are i, i*2, i*4, i*8, r, r*4, and r*8.  The number after the
     * * tells the number of bytes in the integer (i) or floating point (r) value.
     * If no size is specified the i defaults to i*2 and r defaults to r*4.  These
     * can be followed by an optional [#] where # is the number of that type you
     * want to read in.</p>
     * <p>The method returns an array of doubles with one entry for each value
     * read in.</p> 
     * @param format The format string for what to read.
     * @return An array with the values read in.
     * @throws IOException This will be thrown if there is a problem reading in the values.
     * @throws IllegalArgumentException This is thrown if the format can't be parsed or if the record sizes don't match. 
     */
    public double[] readFortranRecord(String format) throws IOException {
        int recSize=readInt4();
        int bytesRead=0;
        String[] types=format.split(" +");
        List<Double> retList=new ArrayList<Double>();
        for(int i=0; i<types.length; ++i) {
            Matcher m=formatPattern.matcher(types[i]);
            if(m.matches()) {
                int numToRead=1;
                if(m.groupCount()>2 && m.group(3)!=null) {
                    String index=m.group(3);
                    numToRead=Integer.parseInt(index.substring(1,index.length()-1));
                }
                String type=m.group(1);
                if(type.equals("i")) {
                    if(m.groupCount()<2 || m.group(2)==null || m.group(2).equals("*2")) {
                        for(int j=0; j<numToRead; ++j) {
                            retList.add(new Double(readInt2()));
                            bytesRead+=2;
                        }
                    } else if(m.group(2).equals("*4")) {
                        for(int j=0; j<numToRead; ++j) {
                            retList.add(new Double(readInt4()));
                            bytesRead+=4;
                        }
                    } else if(m.group(2).equals("*8")) {
                        for(int j=0; j<numToRead; ++j) {
                            retList.add(new Double(readInt8()));
                            bytesRead+=8;
                        }                        
                    } else {
                        throw new IllegalArgumentException("i parse: The type "+types[i]+" was not recognized.");                        
                    }
                } else if(type.equals("r")) {
                    if(m.groupCount()<2 || m.group(2)==null || m.group(2).equals("*4")) {
                        for(int j=0; j<numToRead; ++j) {
                            retList.add(new Double(readReal4()));
                            bytesRead+=4;
                        }
                    } else if(m.group(2).equals("*8")) {
                        for(int j=0; j<numToRead; ++j) {
                            retList.add(new Double(readReal8()));
                            bytesRead+=8;
                        }                        
                    } else {
                        throw new IllegalArgumentException("r parse: The type "+types[i]+" was not recognized.");
                    }
                } else {
                    throw new IllegalArgumentException("type parse: The type "+types[i]+" was not recognized.");                
                }
            } else {
                throw new IllegalArgumentException("The type "+types[i]+" was not recognized.  Didn't match pattern.");                
            }
        }
        int closeRec=readInt4();
        if(recSize!=bytesRead) {
            throw new IllegalArgumentException("Record length didn't match specification.");
        }
        if(recSize!=closeRec) {
            throw new IllegalArgumentException("Record footer didn't match header.");
        }
        double[] ret=new double[retList.size()];
        for(int i=0; i<ret.length; ++i) {
            ret[i]=retList.get(i);
        }
        return ret;
    }
    
    private DataInput wrapped;
    
    private static Pattern formatPattern=Pattern.compile("([ir])(\\*[248])?(\\[\\d+\\])?");
}

/* This isn't needed.  It's the original version of readReal4.
 * It was written before finding intBitsToFloat, but keeping it because
 * it is hard to recreate and might be useful in the future.
int[] buf=new int[4];
for(int i=0; i<buf.length; i++) {
    buf[i]=wrapped.read();
    if(buf[i]<0) {
        if(i==0) throw new IOException("End of stream reached.");
        else throw new IOException("Insufficient bytes trying to read a real*4: "+i);
    }
}
if(buf[0]==0 && buf[1]==0 && buf[2]==0 && buf[3]==0) return 0.0;
if(buf[3]==0) {
    // !!! Special form.  Need to look into this.
    return 0.0;
}
int sign=(int)buf[3]>>>7;
int exp=((int)buf[3]<<1)+((int)buf[2]>>>7);
int mant=(((int)buf[2]&0x7f)<<16)+((int)buf[1]<<8)+(int)buf[0];
double ret=1.0+(((double)mant)/two23);
ret*=Math.pow(2.0,exp-127);
if(sign!=0) ret*=-1;
return ret;
*/

/* Same as above, but for readReal8.  Not needed, but a pain to rewrite and could be useful.
long[] buf=new long[8];
for(int i=0; i<buf.length; i++) {
    buf[i]=wrapped.read();
    if(buf[i]<0) {
        if(i==0) throw new IOException("End of stream reached.");
        else throw new IOException("Insufficient bytes trying to read a real*8: "+i);
    }
}
if(buf[0]==0 && buf[1]==0 && buf[2]==0 && buf[3]==0 && buf[4]==0 && buf[5]==0 && buf[6]==0 && buf[7]==0) return 0.0;
if(buf[7]==0) {
    // !!! Special form.  Need to look into this.
    return 0.0;
}
long sign=buf[7]>>>7;
long exp=((buf[7]&0x007f)<<4)+(buf[6]>>>4);
long mant=((buf[6]&0x000f)<<48)+(buf[5]<<40)+(buf[4]<<32)+(buf[3]<<24)+(buf[2]<<16)+(buf[1]<<8)+buf[0];
double ret=1.0+(((double)mant)/two52);
ret*=Math.pow(2.0,exp-1023);
if(sign!=0) ret*=-1;
return ret;
*/

//private static double two23=1<<23;
//private static double two52=1l<<52;
