/* Generated by Together */
package edu.swri.swiftvis;

import java.awt.BorderLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.FocusAdapter;
import java.awt.event.FocusEvent;
import java.io.Serializable;
import java.util.Map;
import java.util.NoSuchElementException;

import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextField;

import edu.swri.swiftvis.DataFormula.GroupInformation;
import edu.swri.swiftvis.scheme.SVSchemeUtil;
import edu.swri.swiftvis.scheme.SchemeBoolean;
import edu.swri.swiftvis.scheme.SchemeConsole;
import edu.swri.swiftvis.scheme.SchemeElement;

/**
* This class is intended to allow uses to type in formulas that use parameters
* or values from elements that evaluate to boolean values.  This is mainly used
* for selecting certain elements.  The operators that are understood by this
* class are the following logical operators: =, <, >, <=, >=, &, and, |, or,
* ^, xor, !, not.  Note that for the booleans operators you can use C-ish
* characters or full names.  Also note that the characters are single, unlike
* in C, but they are short circuit.  Also note that equality is a single '='.
*
* All formulas can use parentheses to specify order of operation.  Without them
* the comparisons have highest precidence, followed by and, or, and xor in that
* order.  At the same level they all go left to right as one would expect.
*
* The comparisons compare two numerical expressions.  Those expressions should
* conform to that used by the DataFormula class.
**/
public class BooleanFormula implements Serializable {
    private BooleanFormula() {}
    
    public BooleanFormula(String equation) {
        parse(equation);
    }

    public BooleanFormula(BooleanFormula c) {
        parse(c.equ);
    }
    
    private void parse(String equation) {
        equ=equation.trim();
        if(equ.charAt(0)=='{') {
            int i=1;
            int braceCount=1;
            while(braceCount>0) {
                switch(equ.charAt(i)) {
                case '{':
                    braceCount++;
                    break;
                case '}':
                    braceCount--;
                    break;
                }
                ++i;
            }
            groupInfo=new DataFormula.GroupInformation(equ.substring(0,i));
            equ=equ.substring(i);
        }
        root=parseToTree(equ);
        equ=equation;        
    }
    
    @Override
    public boolean equals(Object o) {
    	if(!(o instanceof BooleanFormula)) return false;
    	BooleanFormula bf=((BooleanFormula)o);
    	return ((groupInfo==null && bf.groupInfo==null) || (groupInfo!=null && groupInfo.equals(bf.groupInfo)))
    		&& bf.root.equals(root);
    }

    public String getFormula() {
        return equ;
    }
    
    public void setFormula(String equation) {
        parse(equation);
        if(inputField!=null) {
            inputField.setText(equation);
        }
    }


	/**
	 * Returns the value of the given expression using the provided DataSink,
	 * primary element.  Special elements will be calculated using the "local"
	 * setting will be used.
	 * @param stream The stream to use.
	 * @throws ArithmeticException This means that it tried an undefinied operation.
	 * @throws NoSuchElementException A provided subscript was out of bounds.
	 */
	public boolean valueOf(DataSink sink,int stream, int elem) {
		return valueOf(sink,stream,elem,null, null);
	}

	/**
	 * Returns the value of the given expression using the provided DataSink,
	 * primary element, and special elements.  Special elements can be null in which
	 * case the "local" setting will be used.
	 * @param stream The stream to use.
	 * @throws ArithmeticException This means that it tried an undefinied operation.
	 * @throws NoSuchElementException A provided subscript was out of bounds.
	 */
	public boolean valueOf(DataSink sink,int stream,int elem, int[] specialElem) {
		return valueOf(sink,stream,elem,specialElem, null);
	}

    /**
     * Returns the value of the given expression using the provided DataSink,
     * primary element, and special elements.  Special elements can be null in which
     * case the "local" setting will be used.
     * @param stream The stream to use.
     * @throws ArithmeticException This means that it tried an undefinied operation.
     * @throws NoSuchElementException A provided subscript was out of bounds.
     */
    public boolean valueOf(DataSink sink,int stream,int elem,int[] specialElem, Map<String,Double> varHash) {
        if(groupInfo!=null) {
            specialElem=groupInfo.getSpecialArray(sink,stream,elem, specialElem);
        }
        return root.eval(sink,stream,elem,specialElem, varHash);
    }

    /**
     * Returns the smallest and largest element numbers that are safe to use
     * with this formula.  This only checks the various data sources used and
     * the offsets in them.
     * @param stream The stream to use.
     */
    public int[] getSafeElementRange(DataSink sink, int stream) {
        return root.getSafeElementRange(sink,stream);
    }

    /**
     * This method returns a text field that can be put into a GUI to edit this formula.
     * If the formula hasn't created one yet, it will create it.  This field has listeners
     * attached to it that will update the formula on action or focus loss.  The provided
     * DataFormulaListener will be notified when the formula is altered.  It can be null.
     */
    public JTextField getTextField(Listener dfl) {
        if(inputField==null) {
            listener=dfl;
            inputField=new JTextField(equ);
            inputField.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) { formulaChanged(); }
        	} );
            inputField.addFocusListener(new FocusAdapter() {
                @Override
                public void focusLost(FocusEvent e) { formulaChanged(); }
        	} );
        }
        return inputField;
    }
    
    public JPanel getLabeledTextField(String text,Listener dfl) {
        JPanel ret=new JPanel(new BorderLayout());
        ret.add(new JLabel(text),BorderLayout.WEST);
        ret.add(getTextField(dfl),BorderLayout.CENTER);
        return ret;
    }
    
    /**
     * This returns a copy of this formula that shares all immutable data, but has a
     * new copy of the mutable data.
     * @return
     */
    public BooleanFormula getParallelCopy() {
        if(groupInfo==null) return this;
        BooleanFormula ret=new BooleanFormula();
        ret.equ=equ;
        ret.root=root;
        ret.groupInfo=new GroupInformation(groupInfo);
        return ret;
    }
    
    public void clearGroupSelection() {
        if(groupInfo!=null) {
            groupInfo.reset();
        }
    }
    
    public void rebuildFormulaString() {
        equ=root.toString();
        if(inputField!=null) inputField.setText(equ);
    }
    
    public void mapSources(Map<Integer,Integer> newSources) {
        root.mapSources(newSources);
        rebuildFormulaString();
    }
    
    @Override
    public String toString() {
        return equ;
    }
    
    public interface Listener {
        void formulaChanged();
    }
    
    private BoolNode parseToTree(String e) {
        int opLoc=-1;
        int opLevel=5;
        int parensCount=0;

        e=e.trim();
        // Find operator =, <, >, <=, >=, &/and, |/or, ^/xor
        for(int i=e.length()-1; i>=0; i--) {
            if(e.charAt(i)=='(') {
                parensCount++;
            } else if(e.charAt(i)==')') {
                parensCount--;
            } else if(parensCount==0 && (e.charAt(i)=='^' || e.regionMatches(false,i,"xor",0,3))) {
                opLoc=i;
                opLevel=0;
                i=-1;
            } else if(parensCount==0 && opLevel>1 && (e.charAt(i)=='|' || e.regionMatches(false,i,"or",0,2))) {
                opLoc=i;
                opLevel=1;
            } else if(parensCount==0 && opLevel>2 && (e.charAt(i)=='&' || e.regionMatches(false,i,"and",0,3))) {
                opLoc=i;
                opLevel=2;
            } else if(parensCount==0 && opLevel>3 && (e.charAt(i)=='<' || e.charAt(i)=='>' || e.charAt(i)=='=')) {
                // Note this doesn't check for <= or >= because = finds them first.  Ambiquity is resolved below.
                opLoc=i;
                opLevel=3;
            }
        }
		if(opLoc<1) {
            if(e.charAt(0)=='(') {
                return parseToTree(e.substring(1,e.length()-1));
            } else if(e.startsWith("!")) {
                return new NotNode(parseToTree(e.substring(1,e.length())));
            } else if(e.startsWith("not")) {
                return new NotNode(parseToTree(e.substring(3,e.length())));
            } else if(e.startsWith("scm(")) {
                return new SchemeNode(e.substring(3,e.length()));
            } else {
                throw new IllegalArgumentException("Poorly formatted boolean string.  Parser left with: "+e);
            }
        } else {
            if(e.charAt(opLoc)=='^') {
                return new XorNode(parseToTree(e.substring(0,opLoc)),parseToTree(e.substring(opLoc+1)));
            } else if(e.regionMatches(false,opLoc,"xor",0,3)) {
                return new XorNode(parseToTree(e.substring(0,opLoc)),parseToTree(e.substring(opLoc+3)));
            } else if(e.charAt(opLoc)=='|') {
                return new OrNode(parseToTree(e.substring(0,opLoc)),parseToTree(e.substring(opLoc+1)));
            } else if(e.regionMatches(false,opLoc,"or",0,2)) {
                return new OrNode(parseToTree(e.substring(0,opLoc)),parseToTree(e.substring(opLoc+2)));
            } else if(e.charAt(opLoc)=='&') {
                return new AndNode(parseToTree(e.substring(0,opLoc)),parseToTree(e.substring(opLoc+1)));
            } else if(e.regionMatches(false,opLoc,"and",0,3)) {
                return new AndNode(parseToTree(e.substring(0,opLoc)),parseToTree(e.substring(opLoc+3)));
            } else if(e.charAt(opLoc)=='=') {
                if(e.charAt(opLoc-1)=='<') {
	                return new LTENode(new DataFormula(e.substring(0,opLoc-1)),new DataFormula(e.substring(opLoc+1)));
                } else if(e.charAt(opLoc-1)=='>') {
	                return new GTENode(new DataFormula(e.substring(0,opLoc-1)),new DataFormula(e.substring(opLoc+1)));
                } else if(e.charAt(opLoc-1)=='!') {
                    return new NENode(new DataFormula(e.substring(0,opLoc-1)),new DataFormula(e.substring(opLoc+1)));
                } else {
	                return new EqualsNode(new DataFormula(e.substring(0,opLoc)),new DataFormula(e.substring(opLoc+1)));
                }
            } else if(e.charAt(opLoc)=='<') {
                return new LTNode(new DataFormula(e.substring(0,opLoc)),new DataFormula(e.substring(opLoc+1)));
            } else if(e.charAt(opLoc)=='>') {
                return new GTNode(new DataFormula(e.substring(0,opLoc)),new DataFormula(e.substring(opLoc+1)));
            }
        }
        return null;
    }

    private void formulaChanged() {
        if(errorHandling || inputField.getText().equals(equ)) return;
        try {
            parse(inputField.getText());
            equ=inputField.getText();
        } catch(Exception e) {
            errorHandling=true;
            JOptionPane.showMessageDialog(inputField,"There was an exception parsing the formula.\nSpecific Error: "+e.getMessage());
            inputField.requestFocus();
            errorHandling=false;
        }
        if(listener!=null) listener.formulaChanged();
    }

    private String equ;
    private BoolNode root;
    private GroupInformation groupInfo;

    private transient JTextField inputField;
    private transient Listener listener;
    private transient boolean errorHandling;
    
    private static final long serialVersionUID=34670923856l;

    private interface BoolNode extends Serializable {
		boolean eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash);
        int[] getSafeElementRange(DataSink sink,int stream);
        void mapSources(Map<Integer,Integer> ns);
    }

    private static class OrNode implements BoolNode {
        public OrNode(BoolNode l,BoolNode r) { left=l; right=r; }
		@Override
        public boolean eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return left.eval(sink,stream,elem,se, varHash)||right.eval(sink,stream,elem,se, varHash); }
        @Override
        public int[] getSafeElementRange(DataSink sink, int stream) {
            int[] l=left.getSafeElementRange(sink,stream);
            int[] r=right.getSafeElementRange(sink,stream);
            l[0]=Math.max(l[0],r[0]);
            l[1]=Math.min(l[1],r[1]);
            return l;
        }
        @Override
        public boolean equals(Object o) {
        	if(!(o instanceof OrNode)) return false;
        	OrNode node=(OrNode)o;
			return (left.equals(node.left) && right.equals(node.right)) ||
				(left.equals(node.right) && right.equals(node.left));
        }
        @Override
        public void mapSources(Map<Integer,Integer> ns) {
            left.mapSources(ns);
            right.mapSources(ns);
        }
        @Override
        public String toString() {
            return "("+left.toString()+" or "+right.toString()+")";
        }

        private BoolNode left;
        private BoolNode right;
        private static final long serialVersionUID=3467092356876l;
    }

    private static class AndNode implements BoolNode {
        public AndNode(BoolNode l,BoolNode r) { left=l; right=r; }
		@Override
        public boolean eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return left.eval(sink,stream,elem,se, varHash)&&right.eval(sink,stream,elem,se, varHash); }
        @Override
        public int[] getSafeElementRange(DataSink sink, int stream) {
            int[] l=left.getSafeElementRange(sink,stream);
            int[] r=right.getSafeElementRange(sink,stream);
            l[0]=Math.max(l[0],r[0]);
            l[1]=Math.min(l[1],r[1]);
            return l;
        }
		@Override
        public boolean equals(Object o) {
			if(!(o instanceof AndNode)) return false;
			AndNode node=(AndNode)o;
			return (left.equals(node.left) && right.equals(node.right)) ||
				(left.equals(node.right) && right.equals(node.left));
		}
        @Override
        public void mapSources(Map<Integer,Integer> ns) {
            left.mapSources(ns);
            right.mapSources(ns);
        }
        @Override
        public String toString() {
            return "("+left.toString()+" and "+right.toString()+")";
        }

        private BoolNode left;
        private BoolNode right;
        private static final long serialVersionUID=346709231784l;
    }

    private static class XorNode implements BoolNode {
        public XorNode(BoolNode l,BoolNode r) { left=l; right=r; }
		@Override
        public boolean eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return left.eval(sink,stream,elem,se, varHash)^right.eval(sink,stream,elem,se, varHash); }
        @Override
        public int[] getSafeElementRange(DataSink sink, int stream) {
            int[] l=left.getSafeElementRange(sink,stream);
            int[] r=right.getSafeElementRange(sink,stream);
            l[0]=Math.max(l[0],r[0]);
            l[1]=Math.min(l[1],r[1]);
            return l;
        }
		@Override
        public boolean equals(Object o) {
			if(!(o instanceof XorNode)) return false;
			XorNode node=(XorNode)o;
			return (left.equals(node.left) && right.equals(node.right)) ||
				(left.equals(node.right) && right.equals(node.left));
		}
        @Override
        public void mapSources(Map<Integer,Integer> ns) {
            left.mapSources(ns);
            right.mapSources(ns);
        }
        @Override
        public String toString() {
            return "("+left.toString()+" xor "+right.toString()+")";
        }

        private BoolNode left;
        private BoolNode right;
        private static final long serialVersionUID=70923856l;
    }

    private static class EqualsNode implements BoolNode {
        public EqualsNode(DataFormula l,DataFormula r) { left=l; right=r; }
		@Override
        public boolean eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return left.valueOf(sink,stream,elem,se, varHash)==right.valueOf(sink,stream,elem,se, varHash); }
        @Override
        public int[] getSafeElementRange(DataSink sink, int stream) {
            int[] l=left.getSafeElementRange(sink,stream);
            if(l[1]<0) l[1]=Integer.MAX_VALUE;
            int[] r=right.getSafeElementRange(sink,stream);
            if(r[1]<0) r[1]=Integer.MAX_VALUE;
            l[0]=Math.max(l[0],r[0]);
            l[1]=Math.min(l[1],r[1]);
            return l;
        }
		@Override
        public boolean equals(Object o) {
			if(!(o instanceof EqualsNode)) return false;
			EqualsNode node=(EqualsNode)o;
			return (left.equals(node.left) && right.equals(node.right)) ||
				(left.equals(node.right) && right.equals(node.left));
		}
        @Override
        public void mapSources(Map<Integer,Integer> ns) {
            left.mapSources(ns);
            right.mapSources(ns);
        }
        @Override
        public String toString() {
            return "("+left.toString()+"="+right.toString()+")";
        }

        private DataFormula left;
        private DataFormula right;
        private static final long serialVersionUID=1645823856l;
    }

    private static class GTNode implements BoolNode {
        public GTNode(DataFormula l,DataFormula r) { left=l; right=r; }
		@Override
        public boolean eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return left.valueOf(sink,stream,elem,se, varHash)>right.valueOf(sink,stream,elem,se, varHash); }
        @Override
        public int[] getSafeElementRange(DataSink sink, int stream) {
            int[] l=left.getSafeElementRange(sink,stream);
            if(l[1]<0) l[1]=Integer.MAX_VALUE;
            int[] r=right.getSafeElementRange(sink,stream);
            if(r[1]<0) r[1]=Integer.MAX_VALUE;
            l[0]=Math.max(l[0],r[0]);
            l[1]=Math.min(l[1],r[1]);
            return l;
        }
		@Override
        public boolean equals(Object o) {
			if(!(o instanceof GTNode)) return false;
			GTNode node=(GTNode)o;
			return left.equals(node.left) && right.equals(node.right);
		}
        @Override
        public void mapSources(Map<Integer,Integer> ns) {
            left.mapSources(ns);
            right.mapSources(ns);
        }
        @Override
        public String toString() {
            return "("+left.toString()+">"+right.toString()+")";
        }

        private DataFormula left;
        private DataFormula right;
        private static final long serialVersionUID=6894912367l;
    }

    private static class LTNode implements BoolNode {
        public LTNode(DataFormula l,DataFormula r) { left=l; right=r; }
		@Override
        public boolean eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return left.valueOf(sink,stream,elem,se, varHash)<right.valueOf(sink,stream,elem,se, varHash); }
        @Override
        public int[] getSafeElementRange(DataSink sink, int stream) {
            int[] l=left.getSafeElementRange(sink,stream);
            if(l[1]<0) l[1]=Integer.MAX_VALUE;
            int[] r=right.getSafeElementRange(sink,stream);
            if(r[1]<0) r[1]=Integer.MAX_VALUE;
            l[0]=Math.max(l[0],r[0]);
            l[1]=Math.min(l[1],r[1]);
            return l;
        }
		@Override
        public boolean equals(Object o) {
			if(!(o instanceof LTNode)) return false;
			LTNode node=(LTNode)o;
			return left.equals(node.left) && right.equals(node.right);
		}
        @Override
        public void mapSources(Map<Integer,Integer> ns) {
            left.mapSources(ns);
            right.mapSources(ns);
        }
        @Override
        public String toString() {
            return "("+left.toString()+"<"+right.toString()+")";
        }

        private DataFormula left;
        private DataFormula right;
        private static final long serialVersionUID=3917560235l;
    }

    private static class GTENode implements BoolNode {
        public GTENode(DataFormula l,DataFormula r) { left=l; right=r; }
		@Override
        public boolean eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return left.valueOf(sink,stream,elem,se, varHash)>=right.valueOf(sink,stream,elem,se, varHash); }
        @Override
        public int[] getSafeElementRange(DataSink sink, int stream) {
            int[] l=left.getSafeElementRange(sink,stream);
            if(l[1]<0) l[1]=Integer.MAX_VALUE;
            int[] r=right.getSafeElementRange(sink,stream);
            if(r[1]<0) r[1]=Integer.MAX_VALUE;
            l[0]=Math.max(l[0],r[0]);
            l[1]=Math.min(l[1],r[1]);
            return l;
        }
		@Override
        public boolean equals(Object o) {
			if(!(o instanceof GTENode)) return false;
			GTENode node=(GTENode)o;
			return left.equals(node.left) && right.equals(node.right);
		}
        @Override
        public void mapSources(Map<Integer,Integer> ns) {
            left.mapSources(ns);
            right.mapSources(ns);
        }
        @Override
        public String toString() {
            return "("+left.toString()+">="+right.toString()+")";
        }

        private DataFormula left;
        private DataFormula right;
        private static final long serialVersionUID=67235807124l;
    }

    private static class LTENode implements BoolNode {
        public LTENode(DataFormula l,DataFormula r) { left=l; right=r; }
		@Override
        public boolean eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return left.valueOf(sink,stream,elem,se, varHash)<=right.valueOf(sink,stream,elem,se, varHash); }
        @Override
        public int[] getSafeElementRange(DataSink sink, int stream) {
            int[] l=left.getSafeElementRange(sink,stream);
            if(l[1]<0) l[1]=Integer.MAX_VALUE;
            int[] r=right.getSafeElementRange(sink,stream);
            if(r[1]<0) r[1]=Integer.MAX_VALUE;
            l[0]=Math.max(l[0],r[0]);
            l[1]=Math.min(l[1],r[1]);
            return l;
        }
		@Override
        public boolean equals(Object o) {
			if(!(o instanceof LTENode)) return false;
			LTENode node=(LTENode)o;
			return left.equals(node.left) && right.equals(node.right);
		}
        @Override
        public void mapSources(Map<Integer,Integer> ns) {
            left.mapSources(ns);
            right.mapSources(ns);
        }
        @Override
        public String toString() {
            return "("+left.toString()+"<="+right.toString()+")";
        }

        private DataFormula left;
        private DataFormula right;
        private static final long serialVersionUID=54680726l;
    }

    private static class NENode implements BoolNode {
        public NENode(DataFormula l,DataFormula r) { left=l; right=r; }
        @Override
        public boolean eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return left.valueOf(sink,stream,elem,se, varHash)!=right.valueOf(sink,stream,elem,se, varHash); }
        @Override
        public int[] getSafeElementRange(DataSink sink, int stream) {
            int[] l=left.getSafeElementRange(sink,stream);
            if(l[1]<0) l[1]=Integer.MAX_VALUE;
            int[] r=right.getSafeElementRange(sink,stream);
            if(r[1]<0) r[1]=Integer.MAX_VALUE;
            l[0]=Math.max(l[0],r[0]);
            l[1]=Math.min(l[1],r[1]);
            return l;
        }
        @Override
        public boolean equals(Object o) {
            if(!(o instanceof LTENode)) return false;
            LTENode node=(LTENode)o;
            return left.equals(node.left) && right.equals(node.right);
        }
        @Override
        public void mapSources(Map<Integer,Integer> ns) {
            left.mapSources(ns);
            right.mapSources(ns);
        }
        @Override
        public String toString() {
            return "("+left.toString()+"!="+right.toString()+")";
        }

        private DataFormula left;
        private DataFormula right;
        private static final long serialVersionUID=54680726l;
    }

    private static class NotNode implements BoolNode {
        public NotNode(BoolNode a) { arg=a; }
		@Override
        public boolean eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) { return !arg.eval(sink,stream,elem,se, varHash); }
        @Override
        public int[] getSafeElementRange(DataSink sink, int stream) {
            return arg.getSafeElementRange(sink,stream);
        }
		@Override
        public boolean equals(Object o) {
			if(!(o instanceof NotNode)) return false;
			NotNode node=(NotNode)o;
			return arg.equals(node.arg);
		}
        @Override
        public void mapSources(Map<Integer,Integer> ns) {
            arg.mapSources(ns);
        }
        @Override
        public String toString() {
            return "!("+arg.toString()+")";
        }

        private BoolNode arg;

        private static final long serialVersionUID=35609872365l;
    }
    private static class SchemeNode implements BoolNode {
        public SchemeNode(String c) {
            codeString=c;
        }
        @Override
        public boolean eval(DataSink sink,int stream,int elem, int[] se, Map<String, Double> varHash) {
            if(code==null) code=SchemeConsole.parse(codeString,SVSchemeUtil.defaultGlobalEnvironment());
            return ((SchemeBoolean)code.eval(SVSchemeUtil.formulaEnvironment(sink,elem,se))).booleanValue();
        }
        @Override
        public int[] getSafeElementRange(DataSink sink, int stream) {
            return new int[]{0,sink.getSource(0).getNumElements(0)};
        }
        @Override
        public boolean equals(Object o) {
            if(!(o instanceof SchemeNode)) return false;
            return code.equals(((SchemeNode)o).code);
        }
        @Override
        public void mapSources(Map<Integer,Integer> ns) {}
        @Override
        public String toString() {
            return "scm("+codeString+")";
        }

        private String codeString;
        private transient SchemeElement code;

        private static final long serialVersionUID=3452148972356l;
    }

}
