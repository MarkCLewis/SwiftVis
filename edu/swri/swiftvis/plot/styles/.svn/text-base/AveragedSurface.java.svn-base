/* Generated by Together */

package edu.swri.swiftvis.plot.styles;

import java.awt.BasicStroke;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.geom.Line2D;
import java.awt.geom.Rectangle2D;
import java.io.Serializable;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Map;

import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;

import edu.swri.swiftvis.BooleanFormula;
import edu.swri.swiftvis.DataFormula;
import edu.swri.swiftvis.DataSink;
import edu.swri.swiftvis.plot.AxisOptions;
import edu.swri.swiftvis.plot.Bounded;
import edu.swri.swiftvis.plot.DataPlotStyle;
import edu.swri.swiftvis.plot.PlotArea2D;
import edu.swri.swiftvis.plot.PlotLegend;
import edu.swri.swiftvis.plot.PlotTransform;
import edu.swri.swiftvis.plot.util.ColorGradient;
import edu.swri.swiftvis.plot.util.FormattedString;
import edu.swri.swiftvis.plot.util.LegendHelper;
import edu.swri.swiftvis.plot.util.PlottingHelper;
import edu.swri.swiftvis.util.EditableBoolean;
import edu.swri.swiftvis.util.EditableDouble;
import edu.swri.swiftvis.util.EditableString;
import edu.swri.swiftvis.util.SourceMapDialog;

public final class AveragedSurface implements DataPlotStyle {
    public AveragedSurface(PlotArea2D pa) {
        plotArea=pa;
        bounds=new double[2][2];
        try {
            xFormula=new DataFormula("v[1]");
            xFormula.valueOf(plotArea.getSink(),0, 0);
        } catch(Exception e) {
            xFormula=new DataFormula("1");
        }
        try {
	        yFormula=new DataFormula("v[2]");
            yFormula.valueOf(plotArea.getSink(),0, 0);
        } catch(Exception e) {
	        yFormula=new DataFormula("1");
        }
        colorFormula=new DataFormula("0");
        redoBounds();
    }
    
    private AveragedSurface(AveragedSurface c,PlotArea2D pa) {
        plotArea=pa;
        bounds=new double[c.bounds.length][c.bounds[0].length];
        for(int i=0; i<bounds.length; ++i) {
            for(int j=0; j<bounds[i].length; ++j) {
                bounds[i][j]=c.bounds[i][j];
            }
        }
        name=new EditableString(c.name.getValue());
        columnMatchFormula=new DataFormula(c.columnMatchFormula);
        xFormula=new DataFormula(c.xFormula);
        yFormula=new DataFormula(c.yFormula);
        colorFormula=new DataFormula(c.colorFormula);
        colorDensity=new EditableBoolean(c.colorDensity.getValue());
        colorGradient=new ColorGradient(c.colorGradient);
        alphaFormula=new DataFormula(c.alphaFormula);
        cellWidth=new EditableDouble(c.cellWidth.getValue());
        drawResonances=new EditableBoolean(c.drawResonances.getValue());
        drawSynodicPeriodBounds=new EditableBoolean(c.drawSynodicPeriodBounds.getValue());
        xorDraw=new EditableBoolean(c.xorDraw.getValue());
        legendInfo=new ASLegend(c.legendInfo);
    }
    
    public String toString() { return "Averaged Surface - "+name.getValue(); }

    public static String getTypeDescription() { return "Averaged Surface Plot"; }

    public void redoBounds(){
        if(!plotArea.hasData()) return;
		int[] indexBounds=xFormula.getSafeElementRange(plotArea.getSink(), 0);
        DataFormula.checkRangeSafety(indexBounds,plotArea.getSink());
		if(indexBounds[1]>0) {
			bounds[0][0]=xFormula.valueOf(plotArea.getSink(),0, indexBounds[0]);
			bounds[0][1]=bounds[0][0];
			for(int i=indexBounds[0]+1; i<indexBounds[1]; i++) {
				double val=xFormula.valueOf(plotArea.getSink(),0, i);
				if(val<bounds[0][0]) bounds[0][0]=val;
				if(val>bounds[0][1]) bounds[0][1]=val;
			}
		} else {
			bounds[0][0]=0;
			bounds[0][1]=10;
		}
		indexBounds=yFormula.getSafeElementRange(plotArea.getSink(), 0);
        DataFormula.checkRangeSafety(indexBounds,plotArea.getSink());
		if(indexBounds[1]>indexBounds[0]) {
			bounds[1][0]=yFormula.valueOf(plotArea.getSink(),0, indexBounds[0]);
			bounds[1][1]=bounds[1][0];
			for(int i=indexBounds[0]+1; i<indexBounds[1]; i++) {
				double val=yFormula.valueOf(plotArea.getSink(),0, i);
				if(val<bounds[1][0]) bounds[1][0]=val;
				if(val>bounds[1][1]) bounds[1][1]=val;
			}
		} else {
			bounds[1][0]=0;
			bounds[1][1]=10;
		}
    }

    /**
     * This draws the plot into the specified Graphics object.  It assumes that
     * the transform and clipping for that Graphics object have all been set up
     * so that the markers can be drawn at their normal locations.  The xSize
     * and ySize are passed in so that it can figure out how large to make the
     * markers if needed.
     */
    public void drawToGraphics(Graphics2D g,PlotTransform trans){
        DataSink sink=plotArea.getSink();
		int[] indexBounds=xFormula.getSafeElementRange(sink, 0);
		int[] tmp=yFormula.getSafeElementRange(sink, 0);
		if(tmp[0]>indexBounds[0]) indexBounds[0]=tmp[0];
		if(tmp[1]<indexBounds[1]) indexBounds[1]=tmp[1];
		if(!colorDensity.getValue()) {
			int[] tmp2=colorFormula.getSafeElementRange(sink, 0);
			if(tmp2[0]>indexBounds[0]) indexBounds[0]=tmp2[0];
			if(tmp2[1]<indexBounds[1]) indexBounds[1]=tmp2[1];
		}
		if(indexBounds[1]<=indexBounds[0]) return;
        DataFormula.checkRangeSafety(indexBounds,plotArea.getSink());
		double Yval=columnMatchFormula.valueOf(sink,0, indexBounds[0]);
        int lineCount=1;
		for(int i=indexBounds[0]+1; i<indexBounds[1] && columnMatchFormula.valueOf(sink,0, i)==Yval; i++) {
			lineCount++;
		}
		double[] xValue=new double[lineCount];
		double[] yValue=new double[lineCount];
        if(xorDraw.getValue()) {
            g.setXORMode(Color.BLACK);
        }
		for(int i=indexBounds[0]; i<indexBounds[1]; ) {
			double lastX=0.0,lastY=0.0;
			for(int j=0; j<lineCount && i<indexBounds[1]; j++,i++) {
				double x=xFormula.valueOf(sink,0, i);
				double y=yFormula.valueOf(sink,0, i);
				if(i>lineCount && j>0) {
					double val=0.0;
					if(colorDensity.getValue()) {
						val=1.0/(cellWidth.getValue()*Math.abs(y-lastY));
					} else if(colorFormula!=null) {
						val=colorFormula.valueOf(plotArea.getSink(),0, i);
					}
					Color col=colorGradient.getColor(val,(float)alphaFormula.valueOf(plotArea.getSink(),0, i));
					g.setPaint(col);
					PlottingHelper.fillQuadArea(g,trans,xValue[j],yValue[j],xValue[j-1],yValue[j-1],lastX,lastY,x,y);
				}
				if(j>0) {
					xValue[j-1]=lastX;
					yValue[j-1]=lastY;
				}
				lastX=x;
				lastY=y;
			}
			xValue[lineCount-1]=lastX;
			yValue[lineCount-1]=lastY;
		}
        g.setPaintMode();
        g.setStroke(new BasicStroke(1));
        if(drawResonances.getValue()) {
            g.setColor(Color.black);
            int resNum=(int)(2.0/(3.0*bounds[1][0]));
            double resLoc=2.0/(3.0*resNum);
            while(resLoc<bounds[1][1]) {
                g.draw(new Line2D.Double(bounds[0][0],resLoc,bounds[0][1],resLoc));
                //PlottingHelper.drawLine(g,bounds[0][0],resLoc,bounds[0][1],resLoc,xSize*0.002,ySize*0.002);
                resNum--;
	            resLoc=2.0/(3.0*resNum);
            }
        }
        if(drawSynodicPeriodBounds.getValue()) {
            g.setColor(Color.blue);
            int markNum=(int)(bounds[0][0]/(2.0*Math.PI));
            while(markNum*2.0*Math.PI<bounds[0][1]) {
                g.draw(new Line2D.Double(markNum*2.0*Math.PI,bounds[1][0],markNum*2.0*Math.PI,bounds[1][1]));
                //PlottingHelper.drawLine(g,markNum*2.0*Math.PI,bounds[1][0],markNum*2.0*Math.PI,bounds[1][1],xSize*0.002,ySize*0.002);
                markNum++;
            }
        }
    }

    /**
     * Returns the min and max values for each dimension that this style
     * supports.  The first index tells which dimension we are looking at and
     * the second index is 0 for min and 1 for max.
     * @return The bounds for this data.
     */
    public double[][] getBounds(){
        double[][] ret=new double[bounds.length][2];
        for(int i=0; i<bounds.length; i++) {
            ret[i][0]=bounds[i][0];
            ret[i][1]=bounds[i][1];
        }
        return ret;
    }

    public PlotLegend getLegendInformation() {
        return legendInfo;
    }

    public JComponent getPropertiesPanel(){
        if(propPanel==null) {
            propPanel=new JPanel(new BorderLayout());
            JPanel northPanel=new JPanel(new GridLayout(7,1));
            northPanel.setBorder(BorderFactory.createTitledBorder("Data Set"));

            JButton mapButton=new JButton("Remap Sources");
            mapButton.addActionListener(new ActionListener() {
                @Override public void actionPerformed(ActionEvent e) {
                    Map<Integer,Integer> newSources=SourceMapDialog.showDialog(propPanel);
                    if(newSources!=null) mapSources(newSources);
                }
            });
            northPanel.add(mapButton);
            
			JPanel tmpPanel=new JPanel(new BorderLayout());
			tmpPanel.add(new JLabel("Name"),BorderLayout.WEST);
			tmpPanel.add(name.getTextField(null),BorderLayout.CENTER);
			northPanel.add(tmpPanel);

            tmpPanel=new JPanel(new BorderLayout());
            tmpPanel.add(new JLabel("Primary Formula"),BorderLayout.WEST);
            tmpPanel.add(xFormula.getTextField(null),BorderLayout.CENTER);
            northPanel.add(tmpPanel);

			tmpPanel=new JPanel(new BorderLayout());
			tmpPanel.add(new JLabel("Secondary Formula"),BorderLayout.WEST);
			tmpPanel.add(yFormula.getTextField(null),BorderLayout.CENTER);
			northPanel.add(tmpPanel);

			tmpPanel=new JPanel(new BorderLayout());
			tmpPanel.add(colorDensity.getCheckBox("Use Density? (else Formula)",null),BorderLayout.WEST);
			tmpPanel.add(colorFormula.getTextField(null),BorderLayout.CENTER);
            northPanel.add(tmpPanel);

            JButton button=new JButton("Change Gradient");
            button.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) { colorGradient.edit(); }
            } );
            northPanel.add(button);

            tmpPanel=new JPanel(new BorderLayout());
            tmpPanel.add(new JLabel("Alpha Formula"),BorderLayout.WEST);
            tmpPanel.add(alphaFormula.getTextField(null),BorderLayout.CENTER);
            northPanel.add(tmpPanel);

            propPanel.add(northPanel,BorderLayout.NORTH);

            JPanel centerPanel=new JPanel(new BorderLayout());
            northPanel=new JPanel(new GridLayout(5,1));

			tmpPanel=new JPanel(new BorderLayout());
			tmpPanel.add(new JLabel("Column Match Formula"),BorderLayout.WEST);
			tmpPanel.add(columnMatchFormula.getTextField(null),BorderLayout.CENTER);
			northPanel.add(tmpPanel);

            northPanel.add(drawResonances.getCheckBox("Draw Resonance Markers?",null));

            northPanel.add(drawSynodicPeriodBounds.getCheckBox("Draw Orbit Markers?",null));

            tmpPanel=new JPanel(new BorderLayout());
            tmpPanel.add(new JLabel("Cell Width"),BorderLayout.WEST);
            tmpPanel.add(cellWidth.getTextField(null),BorderLayout.CENTER);
            northPanel.add(tmpPanel);
            
            northPanel.add(xorDraw.getCheckBox("Draw with XOR?",null));

            centerPanel.add(northPanel,BorderLayout.NORTH);
			propPanel.add(centerPanel,BorderLayout.CENTER);
            
            button=new JButton("Apply Changes");
            button.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
                    plotArea.forceRedraw();
                    plotArea.fireRedraw();
                }
            });
            propPanel.add(button,BorderLayout.SOUTH);
        }
        return propPanel;
    }

    public AveragedSurface copy(PlotArea2D pa) {
        return new AveragedSurface(this,pa);
    }
    
    private void mapSources(Map<Integer,Integer> newSources) {
        if(newSources.isEmpty()) return;
        Field[] fields=this.getClass().getDeclaredFields();
        for(Field f:fields) {
            if(DataFormula.class.isAssignableFrom(f.getType())) {
                try {
                    ((DataFormula)f.get(this)).mapSources(newSources);
                } catch (IllegalArgumentException e) {
                    e.printStackTrace();
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                }
            }
            if(BooleanFormula.class.isAssignableFrom(f.getType())) {
                try {
                    ((BooleanFormula)f.get(this)).mapSources(newSources);
                } catch (IllegalArgumentException e) {
                    e.printStackTrace();
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                }                
            }
        }
    }

    private EditableString name=new EditableString("Default");
    private double[][] bounds;
    private PlotArea2D plotArea;
    private DataFormula columnMatchFormula = new DataFormula("v[0]");
    private DataFormula xFormula = new DataFormula("v[0]");
    private DataFormula yFormula = new DataFormula("v[1]");
    private DataFormula colorFormula = new DataFormula("0");
    private EditableBoolean colorDensity=new EditableBoolean(true);
    private ColorGradient colorGradient = new ColorGradient();
    private DataFormula alphaFormula=new DataFormula("1");
    private EditableDouble cellWidth=new EditableDouble(1);
    private EditableBoolean drawResonances=new EditableBoolean(false);
    private EditableBoolean drawSynodicPeriodBounds=new EditableBoolean(false);
    private EditableBoolean xorDraw=new EditableBoolean(false);
    private ASLegend legendInfo=new ASLegend();

    private transient JPanel propPanel;

    private static final long serialVersionUID=32567029872364l;
    
    private class ASLegend implements PlotLegend,Serializable,AxisOptions.AxisOptionUser,Bounded {
        public ASLegend() {
            ArrayList<Bounded> list=new ArrayList<Bounded>();
            list.add(this);
            axisOptions.setDataPlots(list);
        }
        public ASLegend(ASLegend c) {
            drawn=new EditableBoolean(c.drawn.getValue());
            drawVertical=new EditableBoolean(c.drawVertical.getValue());
            vertSize=new EditableDouble(c.vertSize.getValue());
            legendName=new FormattedString(c.legendName.getValue());
            axisOptions=new AxisOptions(c.axisOptions,this);
            ArrayList<Bounded> list=new ArrayList<Bounded>();
            list.add(this);
            axisOptions.setDataPlots(list);
        }
        public JComponent getPropertiesPanel() {
            if(propPanel==null) {
                propPanel=new JPanel(new BorderLayout());
                JPanel innerPanel=new JPanel(new GridLayout(4,1));
                if(legendName.getValue().length()<1) {
                    legendName.setValue(name.getValue());
                }
                JPanel innerPanel2=new JPanel(new BorderLayout());
                innerPanel2.add(new JLabel("Label"),BorderLayout.WEST);
                innerPanel2.add(legendName.getTextField(null));
                innerPanel.add(innerPanel2);
                innerPanel.add(drawn.getCheckBox("Draw in Legend?",null));
                innerPanel.add(drawVertical.getCheckBox("Orient Gradient Vertically?",null));
                JPanel sizePanel=new JPanel(new BorderLayout());
                sizePanel.add(new JLabel("Relative Vertical Size"),BorderLayout.WEST);
                sizePanel.add(vertSize.getTextField(null),BorderLayout.CENTER);
                innerPanel.add(sizePanel);
                propPanel.add(innerPanel,BorderLayout.NORTH);
                
                propPanel.add(axisOptions.getPropertiesPanel(),BorderLayout.CENTER);
                
                JButton applyButton=new JButton("Apply Changes");
                applyButton.addActionListener(new ActionListener() {
                    public void actionPerformed(ActionEvent e) {
                        plotArea.fireRedraw();
                    }
                });
                propPanel.add(applyButton,BorderLayout.SOUTH);
            }
            return propPanel;
        }
        
        public void drawToGraphics(Graphics2D g,Rectangle2D bounds) {
            LegendHelper.drawTextAndGradient(g,bounds,legendName,plotArea.getSink(),axisOptions,colorGradient,drawVertical.getValue());
        }
        
        public boolean isDrawn() {
            return drawn.getValue();
        }
        
        public double relativeVerticalSize() {
            return vertSize.getValue();
        }

        public void fireRedraw() {
        }
        
        public void forceRedraw() {
        }
        
        public void syncGUI() {
        }
        
        public DataSink getSink() {
            return plotArea.getSink();
        }

        public double[][] getBounds() {
            return new double[][]{colorGradient.getBounds(),{0,1}};
        }
        
        private FormattedString legendName=new FormattedString("");
        private EditableBoolean drawn = new EditableBoolean(false);
        private EditableBoolean drawVertical=new EditableBoolean(false);
        private EditableDouble vertSize = new EditableDouble(3.0);
        private AxisOptions axisOptions=new AxisOptions(this);
        
        private transient JPanel propPanel;
        private static final long serialVersionUID=487235690873246l;
    }    
}
