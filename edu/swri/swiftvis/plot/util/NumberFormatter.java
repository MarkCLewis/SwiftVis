/* Generated by Together */

package edu.swri.swiftvis.plot.util;


/**
* This class is used to do formatting on numbers to make them look good.
**/
public class NumberFormatter {
//    public static void main(String[] args) {
//        double[] bnds={0.1,100.0};
//        cleanBounds(bnds);
//        System.out.println(bnds[0]+" "+bnds[1]);
//        bnds[0]=0.856; bnds[1]=0.857;
//        cleanBounds(bnds);
//        System.out.println(bnds[0]+" "+bnds[1]);
//        bnds[0]=-5.4; bnds[1]=9.857;
//        cleanBounds(bnds);
//        System.out.println(bnds[0]+" "+bnds[1]);
//        bnds[0]=-10.856; bnds[1]=-4.573;
//        cleanBounds(bnds);
//        System.out.println(bnds[0]+" "+bnds[1]);
//        System.out.println(format(bnds[0],2)+" "+format(bnds[1],2));
//        System.out.println(format(bnds[0],3)+" "+format(bnds[1],3));
//        System.out.println(format(bnds[0],6)+" "+format(bnds[1],6));
//        System.out.println(format(bnds[0],0.02,bnds[1])+" "+format(bnds[1],0.02,bnds[1]));
//        System.out.println(format(bnds[0],0.002,bnds[1])+" "+format(bnds[1],0.002,bnds[1]));
//    }
//
//    /**
//     * Sets the values to something that contains the bounds passed in, but
//     * which uses numbers rounded for better display.
//     */
//    public static void cleanBoundsOld(double[] minMax) {
//    	if(minMax[0]==minMax[1]) return;
//		double logDiff=Math.ceil(Math.log(Math.abs(minMax[1]-minMax[0]))/Math.log(10.0));
//        int tmp=(int)(minMax[1]/Math.pow(10.0,logDiff-2))+1;
//		double max=tmp*Math.pow(10.0,logDiff-2);
//        tmp=(int)(minMax[0]/Math.pow(10.0,logDiff-2))-1;
//		double min=tmp*Math.pow(10.0,logDiff-2);
//		if(min*minMax[0]<0.0) min=0.0;
//		if(max*minMax[1]<0.0) max=0.0;
//        minMax[0]=min;
//        minMax[1]=max;
//    }
//
    /**
     * Sets the values to something that contains the bounds passed in, but
     * which uses numbers rounded for better display.  It returns a recommended
     * step to use between intervals.
     */
    public static double cleanBounds(double[] minMax) {
        double ret=Math.abs(minMax[1]-minMax[0])*0.2;
        if(ret==0.0) return 1.0;
        double log=Math.floor(Math.log10(ret));
        double test=Math.pow(10,log);
        int mult;
        for(mult=2; mult*test<ret; ++mult);
        return (mult-1)*test;
    }
    
    public static String format(String formatString,double num) {
        String label;
        if(formatString.endsWith("d") || formatString.endsWith("o") || formatString.endsWith("x") || formatString.endsWith("X")) {
            label=String.format(formatString, (int)num);
        } else {
            label=String.format(formatString, num);
        }
        int index=label.indexOf('e');
        if(index>=0) {
            String exp=label.substring(index+1);
            String sgn="";
            if(exp.charAt(0)=='-') sgn="-";
            exp=exp.substring(1);
            while(exp.length()>1 && exp.charAt(0)=='0') exp=exp.substring(1);
            label=label.substring(0,index)+" \\times 10^{"+sgn+exp+"}";
        }
        return label;
    }
//
//    /**
//     * Sets the values to something that contains the bounds passed in, but
//     * which uses numbers rounded for better display.  It returns a recommended
//     * step to use between intervals.  The second parameter tells it how many
//     * significant figures will be 
//     */
//    public static double cleanBounds(double[] minMax,int sigFigs) {
//        return (minMax[1]-minMax[0])*0.2;
//    }
//
//    public static String format(double num,int sigFigs) {
//        if(num==0.0) {
//            String ret="0.";
//            for(int i=1; i<sigFigs; i++) ret+="0";
//            return ret;
//        }
//        double log=Math.floor(Math.log(Math.abs(num))/Math.log(10.0));
//        double val=num*Math.pow(10.0,-log);
//        String ret=Double.toString(val);
//        if(num<0.0) sigFigs++;
//        if(ret.length()>sigFigs+1) {
//            if(ret.length()>sigFigs+1) {
//                char rnd=ret.charAt(sigFigs+1);
//				if(rnd>'4') {
//                    val+=0.5*Math.pow(10.0,-sigFigs+1);
//                    if(val>=10.0) {
//                        val*=0.1;
//                        log++;
//                    }
//                    ret=Double.toString(val);
//                }
//            }
//            ret=ret.substring(0,sigFigs+1);
//        }
//        if(log!=0.0) ret+="e"+(int)log;
//        return ret;
//    }
//
//    public static String format(double num,double spacing,double max) {
//    	if(spacing>Math.abs(1e10*num)) return "0.0";
//    	String ret=Double.toString(num);
//        int eIndex=ret.indexOf('E');
//        String exp;
//        if(eIndex<0) {
//            exp="";
//        } else {
//            exp=ret.substring(eIndex);
//            ret=ret.substring(0,eIndex);
//        }
//    	int pntIndex=ret.indexOf('.');
//    	if(pntIndex<0) return ret+exp;
//    	StringBuffer buf=new StringBuffer(ret);
//    	if(ret.length()>7 && ret.substring(ret.length()-5,ret.length()-1).equals("0000")) {
//    		buf.setLength(buf.length()-1);
//	    	for(int i=buf.length()-1; i>1 && buf.charAt(i)=='0'; --i) {
//	    		buf.setLength(buf.length()-1);
//	    	}
//    	} else if(pntIndex<ret.length()-2 && ret.length()>7 && ret.substring(ret.length()-6,ret.length()-2).equals("0000")) {
//    		buf.setLength(buf.length()-2);
//	    	for(int i=buf.length()-1; i>1 && buf.charAt(i)=='0'; --i) {
//	    		buf.setLength(buf.length()-1);
//	    	}    		
//    	} else if(ret.length()>7 && ret.substring(ret.length()-6,ret.length()-2).equals("9999")) {
//	    	buf.setLength(buf.length()-2);
//	    	boolean carry=false;
//	    	for(int i=buf.length()-1; i>1 && buf.charAt(i)=='9'; --i) {
//	    		carry=true;
//	    		buf.setLength(buf.length()-1);
//	    	}
//	    	if(carry) {
//	    		if(buf.charAt(buf.length()-1)=='.') {
//                    char c=carryOne(buf.charAt(buf.length()-2));
//                    if(c=='0') {
//                        if(exp.length()>0) {
//                            int e=Integer.parseInt(exp.substring(1));
//                            exp="E"+(e+1);
//                            buf=new StringBuffer("1.");
//                        } else {
//                            int val=Integer.parseInt(buf.substring(0,buf.length()-1));
//                            val++;
//                            buf=new StringBuffer(Integer.toString(val)+".");
//                        }
//                    } else {
//                        buf.setCharAt(buf.length()-2,c);
//                    }
//	    			buf.append('0');
//	    		} else {
//                    char c=carryOne(buf.charAt(buf.length()-1));
//	    			buf.setCharAt(buf.length()-1,c);
//                    if(c=='0') {
//                        buf.setCharAt(buf.length()-2,carryOne(buf.charAt(buf.length()-2)));                        
//                    }
//	    		}
//	    	}
//    	}
//    	return new String(buf)+exp;
//    }

/*        if(num==0.0) return "0.0";
        int sigFigs=(int)(Math.ceil(Math.log(Math.abs(10.0*max/spacing))/Math.log(10.0)))+1;
        double log=Math.floor(Math.log(Math.abs(num))/Math.log(10.0));
        double val=num/Math.pow(10.0,log);
        StringBuffer ret=new StringBuffer(Double.toString(val));
        if(num<0.0) sigFigs++;
        if(ret.length()>sigFigs+1) {
            char rnd=ret.charAt(sigFigs+1);
			if(rnd>'4') {
                val+=0.5*Math.pow(10.0,-sigFigs+1);
                if(val>=10.0) {
                    val*=0.1;
                    log++;
                }
                ret=new StringBuffer(Double.toString(val));
            }
            ret.setLength(sigFigs+1); //substring(0,sigFigs+1);
        }
        if(ret.indexOf("e")<0 && ret.indexOf(".")>=0) {
        	while(ret.charAt(ret.length()-1)=='0')
        		ret.setLength(ret.length()-1);
        	if(ret.charAt(ret.length()-1)=='.') ret.setLength(ret.length()-1);
        }
        if(log!=0.0) {
        	if(log>0.0 && log<3.0) {
        		int cur=ret.indexOf(".");
        		if(cur<0) cur=ret.length();
        		while(log>0.0) {
        			if(ret.length()>cur+1) {
        				char tmp=ret.charAt(cur);
        				ret.setCharAt(cur,ret.charAt(cur+1));
        				ret.setCharAt(cur+1,tmp);
        			} else {
        				ret.append('0');
        			}
        			cur++;
        			log--;
        		}
        	} else {
				ret.append("e"+(int)log);
        	}
        } 
        return new String(ret);
*/
    
//    private static char carryOne(char c) {
//        if(c=='9') return '0';
//        return (char)(c+1);
//    }
    
}
