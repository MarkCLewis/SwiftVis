/* Generated by Together */

package edu.swri.swiftvis.sources;

import javax.swing.*;

import edu.swri.swiftvis.DataElement;
import edu.swri.swiftvis.GraphElement;
import edu.swri.swiftvis.OptionsData;

import java.awt.BorderLayout;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.List;

/**
 * This source represents the contents of a SWIFT discard file.  The discard file stores all
 * of the particles that were discarded during the last timestep and the information on them.
 * We load that into multiple elements.  Each particle gets an element with a time, id, status,
 * x, y, z, vx, vy, vz.  If the user selects to output the planets in addition to the test particles,
 * they also have a mass and radius as additional values.  If you want to use those values in
 * formulas, you must pass the discard information through a filter that will take out all of
 * the test particles or you will get errors trying to read the mass or radius of the test particles.
 * Doing a selection filter with id<0 will work nicely.  The id is p[0]. 
 * 
 * @author Mark Lewis
 */
public class DiscardData extends AbstractSource implements FileSourceInter {
    public static void main(String[] args) {
        String[] s="   a      b  c".split(" +");
        for(String str:s) {
            System.out.println(str);
        }
    }
    
    public DiscardData() {
    }
    
    private DiscardData(DiscardData c,List<GraphElement> l) {
        super(c,l);
        dataFile=c.dataFile;
        program=c.program;
    }

    @Override
    public String getDescription(){ return "Discard Data"; }

    public static String getTypeDescription(){ return "Discard Data"; }

    @Override
    protected void setupSpecificPanelProperties() {
        JPanel panel=new JPanel(new BorderLayout());
        JPanel northPanel=new JPanel(new GridLayout(4,1));
        final JComboBox programComboBox=new JComboBox(new String[]{"SWIFT","SWIFTER"});
        programComboBox.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                program=programComboBox.getSelectedIndex();
            }
        });
        northPanel.add(programComboBox);
        fileLabel=new JLabel((dataFile==null)?"No File Selected":dataFile.getAbsolutePath());
        northPanel.add(fileLabel);
        JButton button=new JButton("Select File");
        button.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                selectFile();
                if(dataFile!=null) fileLabel.setText(dataFile.getAbsolutePath());
            }
        });
        northPanel.add(button);
        button=new JButton("Read File");
        button.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                abstractRedoAllElements();
            }
        });
        northPanel.add(button);
        panel.add(northPanel,BorderLayout.NORTH);
        propPanel.add("Settings",panel);
    }

    /**
     * Tells you what a particular parameter is used for.
     */
    @Override
    public String getParameterDescription(int stream, int which){
        if(program==SWIFT) {
            String[] desc={"ID","Reason","Body","istat[3]"};
            return desc[which];            
        }
        String[] desc={"ID","Status","Body"};
        return desc[which];
    }

    /**
     * Tells you what a particular value is used for.
     */
    @Override
    public String getValueDescription(int stream, int which){
        if(program==SWIFT) {
            String[] desc={"Time","rstat[1]","rstat[2]","rstat[3]","x","y","z","vx","vy","vz"};
            return desc[which];
        }
        String[] desc={"Time","x","y","z","vx","vy","vz","mass","radius"};
        return desc[which];
    }

    @Override
    public int getNumParameters(int stream){
        if(program==SWIFT) return 4;
        return 3;
    }

    @Override
    public int getNumValues(int stream){
        if(program==SWIFT) return 10;
        return 9;
    }

    @Override
    public DiscardData copy(List<GraphElement> l) {
        return new DiscardData(this,l);
    }

    @Override
    public File[] getFiles() {
        return new File[]{dataFile};
    }

    @Override
    public void setFile(int which,File f) {
        dataFile=f;
        if(dataFile!=null && fileLabel!=null) fileLabel.setText(dataFile.getAbsolutePath());
    }

    @Override
    public void rereadFiles() {
        abstractRedoAllElements();        
    }
    
    @Override
    protected void redoAllElements() {
        if(program==SWIFT) readSWIFT();
        else readSWIFTER();
    }
    
    private void selectFile() {
        JFileChooser fileChooser=new JFileChooser(OptionsData.instance().getLastDir());
        if(fileChooser.showOpenDialog(propPanel)==JFileChooser.CANCEL_OPTION) return;
        dataFile=fileChooser.getSelectedFile();
        OptionsData.instance().setLastDir(dataFile.getParentFile());        
    }

    private void readSWIFT() {
        try {
            BufferedReader br=new BufferedReader(new FileReader(dataFile));
            String line=br.readLine();
            float[] vals=new float[10];
            int[] params=new int[4];
            while(line!=null && line.length()>0) {
                vals[0]=Float.parseFloat(line);
                String[] istat=br.readLine().trim().split(" +");
                int istatLines=0;
                int lastIstatLength=0;
                while(Integer.parseInt(istat[0])>0) {
                    params[0]=Integer.parseInt(istat[0]);
                    params[1]=Integer.parseInt(istat[1]);
                    params[2]=Integer.parseInt(istat[2]);
                    params[3]=Integer.parseInt(istat[3]);
                    lastIstatLength=istat.length;
                    String[] rstat=br.readLine().trim().split(" +");
                    boolean flag=true;
                    istatLines=0;
                    while(flag) {
                        try {
                            Integer.parseInt(rstat[0]);
                            istatLines++;
                            istat=rstat;
                            lastIstatLength=istat.length;
                            rstat=br.readLine().trim().split(" +");
                        } catch(NumberFormatException e) {
                            flag=false;
                        }
                    }
                    vals[1]=Float.parseFloat(rstat[0]);
                    vals[2]=Float.parseFloat(rstat[1]);
                    vals[3]=Float.parseFloat(rstat[2]);
                    for(int i=1; 4*i<istatLines*100+istat.length-1; ++i) {
                        br.readLine();
                    }
                    String[] line2=br.readLine().trim().split(" +");
                    vals[4]=Float.parseFloat(line2[0]);
                    vals[5]=Float.parseFloat(line2[1]);
                    vals[6]=Float.parseFloat(line2[2]);
                    String[] line3=br.readLine().trim().split(" +");
                    vals[7]=Float.parseFloat(line3[0]);
                    vals[8]=Float.parseFloat(line3[1]);
                    vals[9]=Float.parseFloat(line3[2]);
                    dataVect.add(new DataElement(params,vals));
                    istat=br.readLine().trim().split(" +");
                }
                params[1]=0;
                params[2]=0;
                params[3]=0;
                while(Integer.parseInt(istat[0])<0) {
                    params[0]=Integer.parseInt(istat[0]);
                    for(int i=0; i<istatLines; ++i) {
                        br.readLine();
                    }
                    for(int i=0; 4*i<istatLines*100+lastIstatLength-1; ++i) {
                        br.readLine();
                    }
                    String[] line2=br.readLine().trim().split(" +");
                    vals[4]=Float.parseFloat(line2[0]);
                    vals[5]=Float.parseFloat(line2[1]);
                    vals[6]=Float.parseFloat(line2[2]);
                    String[] line3=br.readLine().trim().split(" +");
                    vals[7]=Float.parseFloat(line3[0]);
                    vals[8]=Float.parseFloat(line3[1]);
                    vals[9]=Float.parseFloat(line3[2]);
                    dataVect.add(new DataElement(params,vals));
                    istat=br.readLine().trim().split(" +");
                }
                for(int i=0; i<istatLines+1; ++i) {
                    line=br.readLine();
                }
            }
            br.close();
        } catch(FileNotFoundException e) {
            JOptionPane.showMessageDialog(propPanel,"The file could not be opened for reading.");
            e.printStackTrace();            
        } catch(IOException e) {
            JOptionPane.showMessageDialog(propPanel,"There was an exception trying to read the file.");
            e.printStackTrace();
        }        
    }
    
    private void readSWIFTER() {
        BufferedReader br=null;
        try {
            br=new BufferedReader(new FileReader(dataFile));
            String line=br.readLine();
            float[] vals=new float[9];
            int[] params=new int[2];
            int[] bodyParams=new int[3];
            bodyParams[2]=-1;
            while(line!=null && line.length()>0) {
                String[] header=line.trim().split(" +");
                vals[0]=Float.parseFloat(header[0]);
                int numTPs=Integer.parseInt(header[1]);
                int flag=(header[2].equals("T"))?1:0;
                vals[7]=0;
                vals[8]=0;
                int firstTP=dataVect.size();
                for(int i=0; i<numTPs; ++i) {
                    String[] line1=br.readLine().trim().split(" +");
                    params[0]=Integer.parseInt(line1[1]);
                    params[1]=Integer.parseInt(line1[2]);
                    String[] line2=br.readLine().trim().split(" +");
                    vals[1]=Float.parseFloat(line2[0]);
                    vals[2]=Float.parseFloat(line2[1]);
                    vals[3]=Float.parseFloat(line2[2]);
                    String[] line3=br.readLine().trim().split(" +");
                    vals[4]=Float.parseFloat(line3[0]);
                    vals[5]=Float.parseFloat(line3[1]);
                    vals[6]=Float.parseFloat(line3[2]);
                    dataVect.add(new DataElement(params,vals));
                }
                if(flag!=0) {
                    int nbodies=Integer.parseInt(br.readLine().trim())-1;
                    for(int i=0; i<nbodies; ++i) {                        
                        String[] line1=br.readLine().trim().split(" +");
                        bodyParams[0]=Integer.parseInt(line1[0]);
                        bodyParams[1]=0;
                        vals[7]=Float.parseFloat(line1[1]);
                        vals[8]=Float.parseFloat(line1[2]);
                        String[] line2=br.readLine().trim().split(" +");
                        vals[1]=Float.parseFloat(line2[0]);
                        vals[2]=Float.parseFloat(line2[1]);
                        vals[3]=Float.parseFloat(line2[2]);
                        String[] line3=br.readLine().trim().split(" +");
                        vals[4]=Float.parseFloat(line3[0]);
                        vals[5]=Float.parseFloat(line3[1]);
                        vals[6]=Float.parseFloat(line3[2]);
                        dataVect.add(new DataElement(bodyParams,vals));
                    }
                    for(int i=0; i<numTPs; ++i) {
                        double minDist=-1;
                        int minBody=-1;
                        for(int j=0; j<nbodies; ++j) {
                            double dx=dataVect.get(firstTP+i).getValue(1)-dataVect.get(firstTP+numTPs+j).getValue(1);
                            double dy=dataVect.get(firstTP+i).getValue(2)-dataVect.get(firstTP+numTPs+j).getValue(2);
                            double dz=dataVect.get(firstTP+i).getValue(3)-dataVect.get(firstTP+numTPs+j).getValue(3);
                            double dist=dx*dx+dy*dy+dz*dz;
                            if(minBody<0 || dist<minDist) {
                                minDist=dist;
                                minBody=j;
                            }
                        }
                        dataVect.set(firstTP+i,new DataElement(dataVect.get(firstTP+i),minBody));
                    }
                } else {
                    for(int i=0; i<numTPs; ++i) {
                        dataVect.set(firstTP+i,new DataElement(dataVect.get(firstTP+i),-1));
                    }
                }
                line=br.readLine();
            }
        } catch(FileNotFoundException e) {
            JOptionPane.showMessageDialog(propPanel,"The file could not be opened for reading.");
            e.printStackTrace();            
        } catch(IOException e) {
            JOptionPane.showMessageDialog(propPanel,"There was an exception trying to read the file.");
            e.printStackTrace();
        } finally {
            try {
                if(br!=null) br.close();
            } catch(IOException e) {
                e.printStackTrace();
            }
        }
    }

    private File dataFile;
    private int program;
    
    private transient JLabel fileLabel;
    
    private static final int SWIFT=0;
    //private static final int SWIFTER=1;
    
    private static final long serialVersionUID=5734687324572l;
}
