/* Generated by Together */

package edu.swri.swiftvis.sources;

import java.awt.BorderLayout;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.EOFException;
import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;

import edu.swri.swiftvis.DataElement;
import edu.swri.swiftvis.GraphElement;
import edu.swri.swiftvis.OptionsData;
import edu.swri.swiftvis.util.BinaryInput;
import edu.swri.swiftvis.util.BufferedRandomAccessFile;
import edu.swri.swiftvis.util.EditableBoolean;
import edu.swri.swiftvis.util.EditableDouble;
import edu.swri.swiftvis.util.EditableInt;

/**
 * This class represents a data file for the binary data output.
 * Currently this uses the format for the old SWIFT and not for SWIFTER.
 * That should probably be left as an option.
 **/
public class BinaryPositionData extends AbstractSource implements FileSourceInter {
    public BinaryPositionData() {
    }
    
    public BinaryPositionData(BinaryPositionData c,List<GraphElement> l) {
        super(c,l);
        reader=c.reader;
        oneIn=new EditableInt(c.oneIn.getValue());
        useRange=new EditableBoolean(c.useRange.getValue());
        startRange=new EditableDouble(c.startRange.getValue());
        endRange=new EditableDouble(c.endRange.getValue());
        maxAllowed=c.maxAllowed;
        offset=c.offset;
        fileToRead=c.fileToRead;
        totalElements=c.totalElements;
    }
    	
    public String getDescription(){ return "Binary Position"; }

    public static String getTypeDescription(){ return "Binary Position"; }

    protected void setupSpecificPanelProperties() {
        JPanel outerPanel=new JPanel(new BorderLayout());
		JPanel panel=new JPanel(new GridLayout(4,1));
        final JComboBox readerComboBox=new JComboBox(readers);
        readerComboBox.setSelectedIndex(reader);
        readerComboBox.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                reader=readerComboBox.getSelectedIndex();
            }
        });
        panel.add(readerComboBox);
        
        fileLabel=new JLabel((fileToRead==null)?"No File Selected":fileToRead.getAbsolutePath());
        panel.add(fileLabel);
        JButton button=new JButton("Select File");
        button.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                selectFile();
                if(fileToRead!=null) fileLabel.setText(fileToRead.getAbsolutePath());
            }
        } );
        panel.add(button);
		button=new JButton("Read File");
		button.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) { abstractRedoAllElements(); }
		} );
		panel.add(button);
        outerPanel.add(panel,BorderLayout.NORTH);
		propPanel.add("Settings",outerPanel);
        
        outerPanel=new JPanel(new BorderLayout());
        panel=new JPanel(new GridLayout(5,1));
        JPanel innerPanel=new JPanel(new BorderLayout());
        innerPanel.add(new JLabel("Take 1 timestep in"),BorderLayout.WEST);
        innerPanel.add(oneIn.getTextField(null),BorderLayout.CENTER);
        panel.add(innerPanel);        
        panel.add(useRange.getCheckBox("Select time range?",null));
        EditableDouble.Listener rangeListener=new EditableDouble.Listener() {
            public void valueChanged() { useRange.setValue(true); }
        };
        innerPanel=new JPanel(new BorderLayout());
        innerPanel.add(new JLabel("Selection Start Time"),BorderLayout.WEST);
        innerPanel.add(startRange.getTextField(rangeListener),BorderLayout.CENTER);
        panel.add(innerPanel);
        innerPanel=new JPanel(new BorderLayout());
        innerPanel.add(new JLabel("Selection End Time"),BorderLayout.WEST);
        innerPanel.add(endRange.getTextField(rangeListener),BorderLayout.CENTER);
        panel.add(innerPanel);
        panel.add(new JLabel("You must read the file for changes to take effect."));
        outerPanel.add(panel,BorderLayout.NORTH);
        propPanel.add("Thinning",outerPanel);
        
    }

    /**
     * Tells you what a particular parameter is used for.
     */
    public String getParameterDescription(int stream, int which){
        if(which==0) return "Particle ID";
        return "Format";
    }

    /**
     * Tells you what a particular value is used for.
     */
    public String getValueDescription(int stream, int which){
        return readers[reader].getValueDescription(which);
    }

    public int getNumParameters(int stream){ return readers[reader].numParams(); }

    public int getNumValues(int stream){ return readers[reader].numValues(); }

    @Override
    public DataElement getElement(int i, int stream){
        if(i<0 || i>=totalElements) return null;
    	if(i<offset || i>=offset+dataVect.size()) {
    		redoBuffer(i);
    	}
		return dataVect.get(i-offset);
    }

    /**
     * Returns the number of data elements that this source has in it.  I'm using
     * this instead of an iterator because direct access is much more efficient
     * when trying to make tables of data.
     * @return The number of data elements in this source.
     */
    @Override
    public int getNumElements(int stream) {
        return totalElements;
    }

    public BinaryPositionData copy(List<GraphElement> l) {
        return new BinaryPositionData(this,l);
    }
    
    public File[] getFiles() {
        return new File[]{fileToRead};
    }

    public void setFile(int which,File f) {
        fileToRead=f;
        if(fileToRead!=null && fileLabel!=null) fileLabel.setText(fileToRead.getAbsolutePath());
    }

    public void rereadFiles() {
        abstractRedoAllElements();        
    }
    
    protected void redoAllElements() {
        maxAllowed=OptionsData.instance().getSourceSize()/ELEMENT_SIZE;
        readFile();
    }
    
    private void selectFile() {
        JFileChooser fileChooser=new JFileChooser(OptionsData.instance().getLastDir());
        if(fileChooser.showOpenDialog(propPanel)==JFileChooser.CANCEL_OPTION) return;
        fileToRead=fileChooser.getSelectedFile();
        OptionsData.instance().setLastDir(fileToRead.getParentFile());        
    }

    private void readFile() {
        if(fileToRead==null) {
            JOptionPane.showMessageDialog(propPanel,"You must select a file to read first.");
            return;
        }
        try {
        	if(bis!=null) bis.close();
            raf=new BufferedRandomAccessFile(fileToRead,"r");
	        bis=new BinaryInput(raf);
            filePositions=new ArrayList<PositionElementPair>();
            int[] paramArray=new int[readers[reader].numParams()];
            float[] valueArray=new float[readers[reader].numValues()];
            while(useRange.getValue() && valueArray[0]<startRange.getValue()) {
                readers[reader].readTimestep(bis,dataVect,paramArray,valueArray,false);
            }
            dataVect.clear();
            offset=0;
            filePositions.add(new PositionElementPair(raf.getFilePointer(),offset));
            totalElements=0;
            while(!useRange.getValue() || valueArray[0]<=endRange.getValue()) {
            	totalElements+=readers[reader].readTimestep(bis,dataVect,paramArray,valueArray,true);
                for(int i=1; i<oneIn.getValue(); ++i) {
                    readers[reader].readTimestep(bis,dataVect,paramArray,valueArray,false);
                }
                if(dataVect.size()>=maxAllowed) {
                    filePositions.add(new PositionElementPair(raf.getFilePointer(),totalElements));
                    dataVect.clear();
                    offset=totalElements;
                }
            }
        } catch(EOFException e) {
            // Do nothing here.  We hit end of file and that is OK.
        } catch(IOException e) {
            e.printStackTrace();
        }
    }

    private void redoBuffer(int elemNum) {
        if(bis==null) {
            readFile();
        }
        if(elemNum>=offset && elemNum<offset+dataVect.size()) return;
        dataVect.clear();
        int group;
        for(group=0; group<filePositions.size() && filePositions.get(group).startElement<=elemNum; ++group);
        group--;
        try {
            raf.seek(filePositions.get(group).filePos);
            offset=filePositions.get(group).startElement;
        } catch(IOException e) {
            e.printStackTrace();
        }
        try {
            int[] paramArray = new int[readers[reader].numParams()];
            float[] valueArray = new float[readers[reader].numValues()];
            while(dataVect.size()<maxAllowed) {
                readers[reader].readTimestep(bis,dataVect,paramArray,valueArray,true);
            }
        } catch (EOFException e) {
            e.printStackTrace();
        } catch (IOException e) {
            //			e.printStackTrace();
        }
    }

    // Read Settings
    private int reader;
    
    private static StepReader readers[]={new SWIFTFort(),new SWIFTXDR(),
        new SWIFTERFort(true,true),new SWIFTERXDR(true,true),
        new SWIFTERFort(true,false),new SWIFTERXDR(true,false),
        new SWIFTERFort(false,true),new SWIFTERXDR(false,true),
        new SWIFTERFort(false,false),new SWIFTERXDR(false,false)};

    // Thinning Settings
    private EditableInt oneIn=new EditableInt(1);
    private EditableBoolean useRange=new EditableBoolean(false);
    private EditableDouble startRange=new EditableDouble(0.0);
    private EditableDouble endRange=new EditableDouble(1e10);
    
    // Data for handling large files.
    
    /** The number of elements to hold in memory at one time.  Will round up to get
     * a full timestep. */
    private int maxAllowed;

    private int offset;

    private File fileToRead;

    private int totalElements;
    
    private static final int ELEMENT_SIZE=40;  // Rough size in bytes of each element.

    private transient BinaryInput bis;
    private transient RandomAccessFile raf;
    private transient List<PositionElementPair> filePositions;
    private transient JLabel fileLabel;
    
    private static final long serialVersionUID=934578923694852346l;
    
    private static class PositionElementPair implements Serializable {
        public PositionElementPair(long fp,int se) {
            filePos=fp;
            startElement=se;
        }
        public long filePos;
        public int startElement;
        private static final long serialVersionUID=8235798736327578l;
    }
    
    private static interface StepReader extends Serializable {
        /**
         * This reads in a single timestep.
         * 
         * @param paramArray An array of two ints.  Passed for speed.
         * @param valueArray An array of 7 floats.  Passed for speed. 
         * @return The number of elements read.
         * @throws IOException This signals that the end of the file has been reached.
         */
        int readTimestep(BinaryInput bis,List<DataElement> dataVect,int[] paramArray,float[] valueArray,boolean store) throws IOException;
        
        String getValueDescription(int which);
        
        int numValues();
        int numParams();
    }
    
    private static class SWIFTFort implements StepReader {
        public int readTimestep(BinaryInput bis,List<DataElement> dataVect,int[] paramArray,float[] valueArray,boolean store) throws IOException {
            int ret=0;
            boolean count=true;
            bis.readInt4();  // record header
            valueArray[0]=(float)bis.readReal4();
            if(!dataVect.isEmpty() && dataVect.get(dataVect.size()-1).getValue(0)==valueArray[0]) {
                store=false;
                count=false;
            }
            int nbod=bis.readInt2();
            int ntp=bis.readInt2();
            bis.readInt4();  // record footer
            for(int i=1; i<nbod; i++) {
                bis.readInt4();  // record header
                paramArray[0]=bis.readInt2();
                valueArray[1]=(float)bis.readReal4();
                valueArray[2]=(float)bis.readReal4();
                valueArray[3]=(float)bis.readReal4();
                valueArray[4]=(float)bis.readReal4();
                valueArray[5]=(float)bis.readReal4();
                valueArray[6]=(float)bis.readReal4();
                bis.readInt4();  // record footer
                if(count) ret++;
                if(store) dataVect.add(new DataElement(paramArray,valueArray));
            }
            for(int i=0; i<ntp; i++) {
                bis.readInt4();  // record header
                paramArray[0]=bis.readInt2();
                valueArray[1]=(float)bis.readReal4();
                valueArray[2]=(float)bis.readReal4();
                valueArray[3]=(float)bis.readReal4();
                valueArray[4]=(float)bis.readReal4();
                valueArray[5]=(float)bis.readReal4();
                valueArray[6]=(float)bis.readReal4();
                bis.readInt4();  // record footer
                if(count) ret++;
                if(store) dataVect.add(new DataElement(paramArray,valueArray));
            }
            return ret;            
        }
        public String getValueDescription(int which) {
            String[] ret={"t","a","e","i","OMEGA","omega","M"};
            return ret[which];                        
        }
        public String toString() { return "Swift Real*4"; }
        public int numValues() { return 7; }
        public int numParams() { return 1; }
        private static final long serialVersionUID=64738633542848l;
    }
    private static class SWIFTXDR implements StepReader {
        public int readTimestep(BinaryInput bis,List<DataElement> dataVect,int[] paramArray,float[] valueArray,boolean store) throws IOException {
            int ret=0;
            valueArray[0]=(float)bis.readXDR4();
            if(!dataVect.isEmpty() && dataVect.get(dataVect.size()-1).getValue(0)==valueArray[0]) store=false; 
            bis.readIntXDR4(); // Number of array elements.
            int nbod=bis.readIntXDR4();
            int ntp=bis.readIntXDR4();
            for(int i=1; i<nbod; i++) {
                paramArray[0]=bis.readIntXDR4();
                bis.readIntXDR4(); // Number of array elements.
                valueArray[1]=(float)bis.readXDR4();
                valueArray[2]=(float)bis.readXDR4();
                valueArray[3]=(float)bis.readXDR4();
                valueArray[4]=(float)bis.readXDR4();
                valueArray[5]=(float)bis.readXDR4();
                valueArray[6]=(float)bis.readXDR4();
                ret++;
                if(store) dataVect.add(new DataElement(paramArray,valueArray));
            }
            for(int i=0; i<ntp; i++) {
                paramArray[0]=bis.readIntXDR4();
                bis.readIntXDR4(); // Number of array elements.
                valueArray[1]=(float)bis.readXDR4();
                valueArray[2]=(float)bis.readXDR4();
                valueArray[3]=(float)bis.readXDR4();
                valueArray[4]=(float)bis.readXDR4();
                valueArray[5]=(float)bis.readXDR4();
                valueArray[6]=(float)bis.readXDR4();
                ret++;
                if(store) dataVect.add(new DataElement(paramArray,valueArray));
            }
            return ret;            
        }
        public String getValueDescription(int which) {
            String[] ret={"t","a","e","i","OMEGA","omega","M"};
            return ret[which];                        
        }
        public String toString() { return "Swift XDR4"; }
        public int numValues() { return 7; }
        public int numParams() { return 1; }
        private static final long serialVersionUID=11775786827458l;
    }
    private static class SWIFTERFort implements StepReader {
        public SWIFTERFort(boolean orbel,boolean r4) {
            useOrbel=orbel;
            useR4=r4;
        }
        public int readTimestep(BinaryInput bis,List<DataElement> dataVect,int[] paramArray,float[] valueArray,boolean store) throws IOException {
            int ret=0;
            bis.readInt4();  // record header
            valueArray[0]=readReal(bis);
            if(!dataVect.isEmpty() && dataVect.get(dataVect.size()-1).getValue(0)==valueArray[0]) store=false; 
            int nbod=bis.readInt4();
            int ntp=bis.readInt4();
            paramArray[1]=bis.readInt4();
            bis.readInt4();  // record footer
            for(int i=1; i<nbod; i++) {
                bis.readInt4();  // record header
                paramArray[0]=bis.readInt4();
                valueArray[7]=readReal(bis);
                valueArray[8]=readReal(bis);
                valueArray[1]=readReal(bis);
                valueArray[2]=readReal(bis);
                valueArray[3]=readReal(bis);
                valueArray[4]=readReal(bis);
                valueArray[5]=readReal(bis);
                valueArray[6]=readReal(bis);
                bis.readInt4();  // record footer
                ret++;
                if(store) dataVect.add(new DataElement(paramArray,valueArray));
            }
            valueArray[7]=0;
            for(int i=0; i<ntp; i++) {
                bis.readInt4();  // record header
                paramArray[0]=bis.readInt4();
                valueArray[1]=readReal(bis);
                valueArray[2]=readReal(bis);
                valueArray[3]=readReal(bis);
                valueArray[4]=readReal(bis);
                valueArray[5]=readReal(bis);
                valueArray[6]=readReal(bis);
                bis.readInt4();  // record footer
                ret++;
                if(store) dataVect.add(new DataElement(paramArray,valueArray));
            }
            return ret;            
        }
        public String getValueDescription(int which) {
            if(useOrbel) {
                String[] ret={"t","a","e","i","OMEGA","omega","M","mass","radius"};
                return ret[which];
            } else {
                String[] ret={"t","x","y","z","vx","vy","vz","mass","radius"};
                return ret[which];                
            }
        }
        public String toString() { return "Swifter Real*"+((useR4)?"4":"8")+((useOrbel)?" Orbel":" xv"); }
        public int numValues() { return 9; }
        public int numParams() { return 2; }
        public float readReal(BinaryInput bis) throws IOException {
            if(useR4) {
                return (float)bis.readReal4();
            } else {
                return (float)bis.readReal8();
            }
        }
        private boolean useOrbel;
        private boolean useR4;
        private static final long serialVersionUID=64738633542848l;
    }
    private static class SWIFTERXDR implements StepReader {
        public SWIFTERXDR(boolean orbel,boolean r4) {
            useOrbel=orbel;
            useR4=r4;
        }
        public int readTimestep(BinaryInput bis,List<DataElement> dataVect,int[] paramArray,float[] valueArray,boolean store) throws IOException {
            int ret=0;
            valueArray[0]=readReal(bis);
            if(!dataVect.isEmpty() && dataVect.get(dataVect.size()-1).getValue(0)==valueArray[0]) store=false; 
            bis.readIntXDR4(); // Number of array elements.
            int nbod=bis.readIntXDR4();
            int ntp=bis.readIntXDR4();
            paramArray[1]=bis.readIntXDR4();
            for(int i=1; i<nbod; i++) {
                paramArray[0]=bis.readIntXDR4();
                valueArray[7]=readReal(bis);
                valueArray[8]=readReal(bis);
                bis.readIntXDR4(); // Number of array elements.
                valueArray[1]=readReal(bis);
                valueArray[2]=readReal(bis);
                valueArray[3]=readReal(bis);
                valueArray[4]=readReal(bis);
                valueArray[5]=readReal(bis);
                valueArray[6]=readReal(bis);
                ret++;
                if(store) dataVect.add(new DataElement(paramArray,valueArray));
            }
            valueArray[7]=0;
            valueArray[8]=0;
            for(int i=0; i<ntp; i++) {
                paramArray[0]=bis.readIntXDR4();
                bis.readIntXDR4(); // Number of array elements.
                valueArray[1]=readReal(bis);
                valueArray[2]=readReal(bis);
                valueArray[3]=readReal(bis);
                valueArray[4]=readReal(bis);
                valueArray[5]=readReal(bis);
                valueArray[6]=readReal(bis);
                ret++;
                if(store) dataVect.add(new DataElement(paramArray,valueArray));
            }
            return ret;            
        }
        public String getValueDescription(int which) {
            if(useOrbel) {
                String[] ret={"t","a","e","i","OMEGA","omega","M","mass","radius"};
                return ret[which];
            } else {
                String[] ret={"t","x","y","z","vx","vy","vz","mass","radius"};
                return ret[which];                
            }
        }
        public String toString() { return "Swifter XDR"+((useR4)?"4":"8")+((useOrbel)?" Orbel":" xv"); }
        public int numValues() { return 9; }
        public int numParams() { return 2; }
        public float readReal(BinaryInput bis) throws IOException {
            if(useR4) {
                return (float)bis.readXDR4();
            } else {
                return (float)bis.readXDR8();
            }
        }
        private boolean useOrbel;
        private boolean useR4;
        private static final long serialVersionUID=11775786827458l;
    }
}
