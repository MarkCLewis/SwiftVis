/* Generated by Together */

package edu.swri.swiftvis;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.event.InputEvent;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.geom.GeneralPath;
import java.awt.geom.Line2D;
import java.awt.geom.Rectangle2D;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Hashtable;
import java.util.LinkedList;
import java.util.List;

import javax.swing.JPanel;

import edu.swri.swiftvis.plot.Plot;

/**
* This panel is the main panel for the primary display in the application.
* It is supposed to draw out the graph showing the simulations/datasets with
* filters and plots that the person currently has up.
**/
public class GraphPanel implements MouseListener,MouseMotionListener {
    private GraphPanel() {
        this(null);
    }
    
    private GraphPanel(SwiftVis mf) {
        mainFrame=mf;
        elements=new ArrayList<GraphElement>();
        if(mf!=null) {
            drawPanel=new InnerGraphPanel();
            drawPanel.addMouseListener(this);
            drawPanel.addMouseMotionListener(this);
        }
        workingList=Collections.synchronizedList(new ArrayList<GraphElement>());
        futureWork=Collections.synchronizedList(new ArrayList<GraphElement>());
    }
    
    public static GraphPanel instance(SwiftVis mf) {
        if(inst==null) inst=new GraphPanel(mf);
        return inst;
    }

    public static GraphPanel instance() {
        if(inst==null) inst=new GraphPanel();
        return inst;
    }
    
    public Dimension getPreferredSize() {
        double maxx=1,maxy=1;
        for(GraphElement pe:elements) {
			if(pe.getBounds().getMaxY()>maxy) maxy=pe.getBounds().getMaxY();
			if(pe.getBounds().getMaxX()>maxx) maxx=pe.getBounds().getMaxX();
        }
        return new Dimension((int)maxx,(int)maxy);
    }
    
    public JPanel getDrawPanel() {
        return drawPanel;
    }
    
    public synchronized void newWorkOrder(GraphElement ge) {
    	nwoHelper(ge);
        if(drawPanel!=null) drawPanel.repaint();
    }
    
    public synchronized void blockWhileUpdatesScheduled() {
    	while(!futureWork.isEmpty() || !workingList.isEmpty()) {
    		try {
    			wait();
    		} catch(InterruptedException e) {
    			e.printStackTrace();
    		}
    	}
    }
    
    private void nwoHelper(final GraphElement next) {
		if (!futureWork.contains(next) && !workingList.contains(next)) {
    		addToFutureWork(next);
    		if (next instanceof DataSource) {
    			DataSource cur=(DataSource)next;
    			for (int i=0; i<cur.getNumOutputs(); i++) {
    				nwoHelper(cur.getOutput(i));
    			}
    		}
    	}
    }
    private void addToFutureWork(GraphElement ge) {
		ArrayList<GraphElement> tmp=calcDeps(ge);
		if (tmp.isEmpty()) {
			addToWorkingList(ge);
		} else {
			futureWork.add(ge);
		}
    }
    // call this instead of caching
    private ArrayList<GraphElement> calcDeps(GraphElement ge) {
    	ArrayList<GraphElement> ret = new ArrayList<GraphElement>();
    	if (ge instanceof DataSink) {
    		DataSink cur=(DataSink)ge;
    		for (int i=0; i<cur.getNumSources(); i++) {
    			DataSource source=cur.getSource(i);
    			if (workingList.contains(source)  ||  futureWork.contains(source)) {
    				ret.add(source);	
    			}
    		}
    	}
    	return ret;
    }
    private synchronized void doneProcessing(GraphElement ge) {
    	workingList.remove(ge);
    	if (ge instanceof DataSource) {
	    	DataSource ds=(DataSource)ge;
	    	for (int i=0; i<ds.getNumOutputs(); i++) {
	    		int futureIndex=futureWork.indexOf(ds.getOutput(i));
	    		if (futureIndex!=-1) {
		    		ArrayList<GraphElement> tmp=calcDeps(futureWork.get(futureIndex));
		    		if (tmp.isEmpty()) {
		    			addToWorkingList(futureWork.remove(futureIndex));
		    		}
	    		}
	    	}
    	}
    	notifyAll();
        if(drawPanel!=null) drawPanel.repaint();
    }
    private synchronized void errorProcessing(GraphElement ge) {
    	workingList.remove(ge);
    	if (ge instanceof DataSource) {
	    	DataSource ds=(DataSource)ge;
	    	for (int i=0; i<ds.getNumOutputs(); i++) {
	    		futureWork.remove(ds.getOutput(i));
	    	}
    	}
    	notifyAll();
        drawPanel.repaint();
    }
    private void addToWorkingList(final GraphElement ge) {
    	workingList.add(ge);
    	// new thread
    	new Thread(new Runnable() {
    		public void run() {
    			try {
    				ge.redo();
        			doneProcessing(ge);
    			} catch (Exception e) {
    				e.printStackTrace();
    				errorProcessing(ge);
    			}
    		}
    	}).start();
    }
    
    public void addDataset(DataSource ds,int x,int y) {
    	if (x==-1 && y==-1) {
	        int maxy=0;
	        for(GraphElement pe:elements) {
				if(pe.getBounds().getMaxY()>maxy) maxy=(int)pe.getBounds().getMaxY();
	        }
	        ds.translate(20,maxy+20);
    	} else {
    		ds.translate(x,y);
    	}
        downshiftToNotOverlap(ds);
        elements.add(ds);
        drawPanel.setPreferredSize(getPreferredSize());
        drawPanel.repaint();
    }
    
    public void addFilter(Filter filter,int x,int y) {
        int maxy=0;
        GraphElement firstSelected=(selected.isEmpty())?null:selected.get(0);
        if(firstSelected==null || selected.size()>1) {
        	if (x==-1 && y==-1) {
	            for(GraphElement pe:elements) {
					if(pe.getBounds().getMaxY()>maxy) maxy=(int)pe.getBounds().getMaxY();
		        }
	    	    filter.translate(100,maxy+20);
        	} else {
        		filter.translate(x,y);
        	}
        } else if(firstSelected instanceof DataSource) {
            filter.addInput((DataSource)firstSelected);
	        filter.translate((int)firstSelected.getBounds().getMaxX()+50,(int)firstSelected.getBounds().getY());
        } else if(firstSelected instanceof DataSink) {
            filter.addOutput((DataSink)firstSelected);
            if(selectedLinkNumber!=-1) {
	            filter.addInput((DataSource)((DataSink)firstSelected).getSource(selectedLinkNumber));
				Line2D line=findLine(firstSelected,((DataSink)firstSelected).getSource(selectedLinkNumber));
    		    filter.translate((int)(line.getX1()+0.1*(line.getX2()-line.getX1())),
    		    	(int)(line.getY1()+0.1*(line.getY2()-line.getY1())-25));
            } else {
	    	    filter.translate((int)(firstSelected.getBounds().getMinX()-10*filter.getDescription().length()-50),
	    	    	(int)firstSelected.getBounds().getY());
            }
        }
        downshiftToNotOverlap(filter);
        elements.add(filter);
        drawPanel.setPreferredSize(getPreferredSize());
        drawPanel.revalidate();
        drawPanel.repaint();
    }

    public void addPlot(Plot plot,int x,int y) {
        int maxy=0;
        GraphElement firstSelected=(selected.isEmpty())?null:selected.get(0);
        if(firstSelected==null || selected.size()>1 || !(firstSelected instanceof DataSource) || !plot.validInput((DataSource)firstSelected)) {
    	    if (x==-1 && y==-1) {
	            for(GraphElement pe:elements) {
					if(pe.getBounds().getMaxY()>maxy) maxy=(int)pe.getBounds().getMaxY();
		        }
	    	    plot.translate(400,maxy);
    	    } else {
	    	    plot.translate(x,y);
    	    }
        } else {
            plot.addInput((DataSource)firstSelected);
    	    plot.translate((int)firstSelected.getBounds().getMaxX()+50,(int)firstSelected.getBounds().getY());
        }
        downshiftToNotOverlap(plot);
        elements.add(plot);
        drawPanel.setPreferredSize(getPreferredSize());
        drawPanel.revalidate();
        drawPanel.repaint();
    }

    public void addNote(GraphNote note,int x,int y) {
        int maxy=0;
        GraphElement firstSelected=(selected.isEmpty())?null:selected.get(0);
        if(firstSelected==null || selected.size()>1) {
            if (x==-1 && y==-1) {
                for(GraphElement pe:elements) {
                    if(pe.getBounds().getMaxY()>maxy) maxy=(int)pe.getBounds().getMaxY();
                }
                note.translate(400,maxy);
            } else {
                note.translate(x,y);
            }
        } else {
            note.translate((int)firstSelected.getBounds().getMaxX()+50,(int)firstSelected.getBounds().getY());
        }
        downshiftToNotOverlap(note);
        elements.add(note);
        drawPanel.setPreferredSize(getPreferredSize());
        drawPanel.revalidate();
        drawPanel.repaint();
    }

    public void addSink(DataSink sink,int x,int y) {
        int maxy=0;
        GraphElement firstSelected=(selected.isEmpty())?null:selected.get(0);
        if(firstSelected==null || selected.size()>1 || !(firstSelected instanceof DataSource) || !sink.validInput((DataSource)firstSelected)) {
            if (x==-1 && y==-1) {
	            for(GraphElement pe:elements) {
	                if(pe.getBounds().getMaxY()>maxy) maxy=(int)pe.getBounds().getMaxY();
	            }
	            sink.translate(400,maxy);
            } else {
            	sink.translate(x,y);
            }
        } else {
            sink.addInput((DataSource)firstSelected);
            sink.translate((int)firstSelected.getBounds().getMaxX()+50,(int)firstSelected.getBounds().getY());
        }
        downshiftToNotOverlap(sink);
        elements.add(sink);
        drawPanel.setPreferredSize(getPreferredSize());
        drawPanel.revalidate();
        drawPanel.repaint();
    }

    public void addConnection() {
        connecting=true;
        startX=-1;
        startY=-1;
        curX=-1;
        curY=-1;
    }

    public List<GraphElement> getElements() {
        return elements;
    }
    
    public List<GraphElement> getSelection() {
        return selected;
    }

    public void setElements(List<GraphElement> elems) {
        elements = elems;
        if(drawPanel!=null) drawPanel.repaint();
    }


    /**
     * Used for selecting items in the graph.
     */
    public void mousePressed(MouseEvent e) {
        drawPanel.requestFocus();
        GraphElement clicked=null;
        for(GraphElement pe:elements) {
            if(clicked==null) {
                if(pe.getBounds().contains(e.getX(),e.getY())) {
                    clicked=pe;
                    mainFrame.selectionMade(pe);
                    selectedLinkNumber=-1;
                    lastX=e.getX();
                    lastY=e.getY();
                    if(connecting) {
                        startX=e.getX();
                        startY=e.getY();
                        curX=startX;
                        curY=startY;
                    }
                } else if(!connecting && pe instanceof DataSink) {
                    DataSink sink=(DataSink)pe;
    				for(int j=0; j<sink.getNumSources(); j++) {
    					Line2D line=findLine(sink,sink.getSource(j));
    					if(line.ptSegDist(e.getX(),e.getY())<3) {
                            clicked=sink;
    						selectedLinkNumber=j;
    					}
    				}
                }
            }
        }
        if(clicked==null) {
            selected.clear();
            selecting=true;
            startX=e.getX();
            startY=e.getY();
            curX=startX;
            curY=startY;
            selectedLinkNumber=-1;
        } else {
            if((e.getModifiersEx()&InputEvent.CTRL_DOWN_MASK)!=0) {
                if(selected.contains(clicked)) {
                    selected.remove(clicked);
                } else {
                    selected.add(clicked);
                }
            } else if(!selected.contains(clicked)) {
                selected.clear();
                selected.add(clicked);
            }
        }
        drawPanel.repaint();
        if (e.getButton()==MouseEvent.BUTTON3) {
        	mainFrame.showPopup(drawPanel,e.getX(),e.getY());
        }
    }

    /**
     * Passed through to the selected item if there is one.  If the user
     * has the "make link" option selected then this will set the far side of
     * the connection.
     */
    public void mouseReleased(MouseEvent e) {
        if(selecting) {
            selecting=false;
            curX=e.getX();
            curY=e.getY();
            Rectangle bound=new Rectangle((int)startX,(int)startY,0,0).union(new Rectangle((int)curX,(int)curY,0,0));
            for(GraphElement pe:elements) {
                if(bound.contains(pe.getBounds())) {
                    selected.add(pe);
                }
            }
            selectedLinkNumber=-1;
        } else if(connecting && !selected.isEmpty()) {
            connecting=false;
            for(GraphElement pe:elements) {
                GraphElement firstSelected=(selected.isEmpty())?null:selected.get(0);
				if(pe.getBounds().contains(e.getX(),e.getY())) {
                    if((pe instanceof DataSink) && (firstSelected instanceof DataSource) && ((DataSink)pe).validInput((DataSource)firstSelected)) {
                        ((DataSink)pe).addInput((DataSource)firstSelected);
                    }
                    drawPanel.repaint();
                    return;
				}
			}
        } else {
	        if(selected.size()<1 || selectedLinkNumber>-1) return;
            for(GraphElement pe:selected) {
                int offsetX=e.getX()-lastX;
                int offsetY=e.getY()-lastY;
            	pe.translate(offsetX,offsetY);
            }
            drawPanel.setPreferredSize(getPreferredSize());
        }
        drawPanel.revalidate();
        drawPanel.repaint();
    }

    /** Not Used by this class. */
    public void mouseClicked(MouseEvent e) {
    }

    /** Not Used by this class. */
    public void mouseEntered(MouseEvent e) {}

    /** Not Used by this class. */
    public void mouseExited(MouseEvent e) {}

    /** Not Used by this class. */
    public void mouseMoved(MouseEvent e) {}

    /**
     */
    public void mouseDragged(MouseEvent e) {
        if(connecting || selecting) {
            curX=e.getX();
			curY=e.getY();
        } else {
            if(selected.size()<1 || selectedLinkNumber>-1) return;
            for(GraphElement pe:selected) {
                int offsetX=e.getX()-lastX;
                int offsetY=e.getY()-lastY;
                pe.translate(offsetX,offsetY);
            }
        }
        lastX=e.getX();
        lastY=e.getY();
        drawPanel.revalidate();
        drawPanel.repaint();
    }
    
    public void deleteSelection() {
        if(selectedLinkNumber>=0) {
            DataSink sink=(DataSink)selected.get(0);
            sink.removeInput(sink.getSource(selectedLinkNumber));
        } else {
            for(GraphElement pe:selected) {
                elements.remove(pe);
                if(pe instanceof DataSource) {
                    DataSource source=(DataSource)pe;
                    while(source.getNumOutputs()>0) {
                        source.getOutput(0).removeInput(source);
                    }
                }
                if(pe instanceof DataSink) {
                    DataSink sink=(DataSink)pe;
                    while(sink.getNumSources()>0) {
                        sink.removeInput(sink.getSource(0));
                    }
                }
            }
        }
        selected.clear();
        selectedLinkNumber=-1;
        drawPanel.repaint();
    }

    public void copySelection() {
        clipBoard=copyElements(selected);
    }

    public void cutSelection() {
        copySelection();
        deleteSelection();
    }

    public void pasteClipboard() {
        if(clipBoard==null) return;
        selected=copyElements(clipBoard);
        elements.addAll(selected);
        for(GraphElement pe:selected) {
            downshiftToNotOverlap(pe);
        }
        drawPanel.repaint();
    }
    
    public void selectAll() {
        selected.clear();
        for(GraphElement ge:elements) {
            selected.add(ge);
        }
        drawPanel.repaint();
    }

    private void drawNode(Graphics2D g,GraphElement pe) {
        Rectangle2D bounds=pe.getBounds();
        g.setPaint(Color.white);
        g.draw(bounds);
        pe.drawNode(g);
//        g.setPaint(pe.getPaint());
//        g.draw(bounds);
//        g.setPaint(Color.black);
//        g.drawString(pe.getDescription(),(float)bounds.getX()+10,(float)bounds.getY()+10+drawFont.getLineMetrics(pe.getDescription(),frc).getAscent());
        if(selected.contains(pe) && selectedLinkNumber==-1) {
            g.setPaint(Color.green);
            g.draw(new Rectangle2D.Double(bounds.getMinX()-2,bounds.getMinY()-2,bounds.getWidth()+4,bounds.getHeight()+4));
        }
        if(workingList.contains(pe)) {
        	g.setPaint(Color.red);
        	g.draw(new Rectangle2D.Double(bounds.getMinX()-4,bounds.getMinY()-4,bounds.getWidth()+8,bounds.getHeight()+8));
        }
        if(futureWork.contains(pe)) {
        	g.setPaint(Color.orange);
        	g.draw(new Rectangle2D.Double(bounds.getMinX()-4,bounds.getMinY()-4,bounds.getWidth()+8,bounds.getHeight()+8));
        }
    }

    private void drawLine(Graphics2D g,GraphElement pe1,GraphElement pe2,boolean select) {
        Line2D line=findLine(pe1,pe2);
        if(select) {
	        g.setPaint(Color.green);
        } else {
	        g.setPaint(Color.black);
        }
		g.draw(line);
        double dx=line.getX2()-line.getX1(); 
        double dy=line.getY2()-line.getY1();
        double len=Math.sqrt(dx*dx+dy*dy);
        dx*=10/len;
        dy*=10/len;
        double nx=dy*0.5;
        double ny=-dx*0.5;
        GeneralPath gp=new GeneralPath();
        gp.moveTo((float)line.getX1(),(float)line.getY1());
        gp.lineTo((float)(line.getX1()+dx+nx),(float)(line.getY1()+dy+ny));
        gp.lineTo((float)(line.getX1()+dx-nx),(float)(line.getY1()+dy-ny));
        gp.closePath();
        g.fill(gp);
    }

    private Line2D findLine(GraphElement pe1,GraphElement pe2) {
        double x1,x2,y1,y2;
        Rectangle2D b1=pe1.getBounds();
        Rectangle2D b2=pe2.getBounds();
        if(b1.getX()<b2.getX()) {
            x1=b1.getMaxX();
            x2=b2.getMinX();
        } else {
            x1=b2.getMaxX();
            x2=b1.getMinX();
        }
        if(b1.getY()<b2.getY()) {
            y1=b1.getMaxY();
            y2=b2.getMinY();
        } else {
            y1=b2.getMaxY();
            y2=b1.getMinY();
        }
        if(x2-x1>y2-y1) {
	        if(b1.getX()<b2.getX()) {
                return new Line2D.Double(b1.getMaxX(),b1.getCenterY(),b2.getMinX(),b2.getCenterY());
            } else {
                return new Line2D.Double(b1.getMinX(),b1.getCenterY(),b2.getMaxX(),b2.getCenterY());
            }
        } else {
	        if(b1.getY()<b2.getY()) {
                return new Line2D.Double(b1.getCenterX(),b1.getMaxY(),b2.getCenterX(),b2.getMinY());
            } else {
                return new Line2D.Double(b1.getCenterX(),b1.getMinY(),b2.getCenterX(),b2.getMaxY());
            }
        }
    }
    
    public List<GraphElement> copyElements(List<GraphElement> lst) {
        List<GraphElement> ret=new ArrayList<GraphElement>();
        Hashtable<GraphElement,GraphElement> linkHash=new Hashtable<GraphElement,GraphElement>();
        for(GraphElement ge:lst) {
            GraphElement newElem=ge.copy(lst);
            if(newElem!=null) {
                ret.add(newElem);
                linkHash.put(ge,newElem);
            }
        }
        for(GraphElement ge:ret) {
            ge.relink(linkHash);
        }
        return ret;
    }
    
    private void downshiftToNotOverlap(GraphElement ge) {
        boolean moveMore=true;
        while(moveMore) {
            moveMore=false;
            for(int i=0; i<elements.size() && !moveMore; ++i) {
                if(ge!=elements.get(i) && ge.getBounds().intersects(elements.get(i).getBounds())) moveMore=true;
            }
            if(moveMore) {
                ge.translate(0,10);
            }
        }
    }
    
    private SwiftVis mainFrame;

    private List<GraphElement> elements;
    
    private static GraphPanel inst;

    private transient List<GraphElement> selected=new LinkedList<GraphElement>();

    private transient InnerGraphPanel drawPanel;
    private transient int selectedLinkNumber;
    private transient int lastX;
    private transient int lastY;
    private transient int startX;
    private transient int startY;
    private transient int curX;
    private transient int curY;
    private transient boolean connecting=false;
    private transient boolean selecting=false;
    private transient List<GraphElement> clipBoard;
    private transient List<GraphElement> workingList;
    private transient List<GraphElement> futureWork;
    private transient Font drawFont;
    private static final long serialVersionUID=623489124698l;
    
    private class InnerGraphPanel extends JPanel {
        protected void paintComponent(Graphics gr) {
            Graphics2D g=(Graphics2D)gr;
            if(drawFont==null) {
                drawFont=g.getFont();
            }
            g.setPaint(Color.white);
            g.fillRect(0,0,getWidth(),getHeight());
            g.setStroke(new BasicStroke(1));
            for(GraphElement pe:elements) {
                drawNode(g,pe);
                if(pe instanceof DataSink) {
                    DataSink sink=(DataSink)pe;
                    for(int j=0; j<sink.getNumSources(); j++) {
                        drawLine(g,sink,sink.getSource(j),selected.contains(sink) && (j==selectedLinkNumber || selected.contains(sink.getSource(j))));
                    }
                }
            }
            if(connecting) {
                g.setPaint(Color.black);
                g.draw(new Line2D.Double(startX,startY,curX,curY));
            }
            if(selecting) {
                g.setPaint(Color.black);
                g.draw(new Rectangle((int)startX,(int)startY,0,0).union(new Rectangle((int)curX,(int)curY,0,0)));            
            }
        }

        private static final long serialVersionUID=73590866346836l;
    }
}
