/* Generated by Together */

package edu.swri.swiftvis.plot;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.GridLayout;
import java.awt.Paint;
import java.awt.Rectangle;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.LinkedList;
import java.util.List;

import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JSplitPane;
import javax.swing.JTabbedPane;
import javax.swing.JTree;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreePath;

import edu.swri.swiftvis.DataSink;
import edu.swri.swiftvis.DataSource;
import edu.swri.swiftvis.GraphElement;
import edu.swri.swiftvis.util.GraphLabelString;
import edu.swri.swiftvis.util.SourceInfoPanel;

public class Plot implements DataSink {
    public Plot() {
        inputVector=new ArrayList<DataSource>();
        spec=new PlotSpec(this);
    }
    
    public Plot(Plot c,List<GraphElement> l) {
        label=new GraphLabelString(c.label);
        inputVector=new ArrayList<DataSource>();
        for(DataSource ds:c.inputVector) {
            if(l.contains(ds)) inputVector.add(ds);
        }
        spec=new PlotSpec(this,c.spec);
    }

    @Override
    public boolean validInput(DataSource ds){ return true; }

    @Override
    public void addInput(DataSource input){
        inputVector.add(input);
        input.addOutput(this);
        if(sip!=null) sip.redoSourceList();
        spec.forceRedraw();
        fireRedraw();
    }

    @Override
    public void removeInput(DataSource input){
        inputVector.remove(input);
        input.removeOutput(this);
        if(sip!=null) sip.redoSourceList();
        spec.forceRedraw();
        fireRedraw();
    }

    @Override
    public void moveUpInput(int index) {
        DataSource ds=inputVector.get(index);
        inputVector.set(index,inputVector.get(index-1));
        inputVector.set(index-1,ds);
        if(sip!=null) sip.redoSourceList();        
        spec.forceRedraw();
        fireRedraw();
    }

    @Override
    public DataSource getSource(int which){ return inputVector.get(which); }

    @Override
    public int getNumSources(){ return inputVector.size(); }

    @Override
    public void redo() {
    	sourceAltered(null); // not null?, doesn't look like it matters
    }
    @Override
    public void sourceAltered(DataSource source){
    	if(sip!=null) sip.redoSourceList();
    	spec.forceRedraw();
//    	System.err.println("before fireRedraw() in sourceAltered()");
    	fireRedraw();
    }

    @Override
    public String getDescription(){ return "General Plot"; }

    @Override
    public Rectangle getBounds() {
        return label.getBounds();
    }

    @Override
    public void translate(int dx,int dy) {
        label.translate(dx,dy);
    }

    @Override
    public void clearData() {}

    public Paint getPaint(){ return Color.cyan.darker(); }
    
    @Override
    public void drawNode(Graphics2D g) {
        label.draw(g);
    }

    @Override
    public JComponent getPropertiesPanel(){
        if(propPanel==null) {
            JPanel treePanel=new JPanel(new BorderLayout());
			JButton showButton=new JButton("Show/Redraw");
			showButton.addActionListener(new ActionListener() {
				@Override
                public void actionPerformed(ActionEvent e) { showPlot(); }
			} );
			treePanel.add(showButton,BorderLayout.NORTH);
            tree=new JTree(spec);
            tree.addTreeSelectionListener(new TreeSelectionListener() {
                @Override
                public void valueChanged(TreeSelectionEvent e) { treeSelectionChanged(); }
            } );
			treePanel.add(tree,BorderLayout.CENTER);
            poPropPanel=new JPanel(new GridLayout(1,1));
            poPropPanel.add(spec.getPropertiesPanel());
			JSplitPane splitPanel=new JSplitPane(JSplitPane.VERTICAL_SPLIT,false,new JScrollPane(treePanel),poPropPanel);
            splitPanel.setDividerLocation(0.5);
            propPanel=new JTabbedPane();
            propPanel.addTab("Display",splitPanel);

            sip=new SourceInfoPanel(this);
            propPanel.addTab("Sources",sip);
            
            propPanel.addTab("Label",label.getAreaPanel("Label"));

        }
        return propPanel;
    }

    /**
     * This method will be called when something alters the tree of elements
     * in the plot.
     */
    public void treeAltered(PlotObject node,PlotObject newPO){
        DefaultTreeModel treeModel=(DefaultTreeModel)tree.getModel();
		treeModel.nodeStructureChanged(node);
        if(newPO!=null) {
            LinkedList<PlotObject> list=new LinkedList<PlotObject>();
            while(newPO!=null) {
                list.addFirst(newPO);
                newPO=(PlotObject)newPO.getParent();
            }
            tree.setSelectionPath(new TreePath(list.toArray()));
        }
    }
    
    public PlotSurface getSurface() {
        if(plotFrame==null) plotFrame=new PlotFrame(spec,this);
        return plotFrame.getSurface();
    }

    public void fireRedraw() {
        if(plotFrame==null) return;
        plotFrame.getSurface().redraw();
    }

    @Override
    public Plot copy(List<GraphElement> l) {
        return new Plot(this,l);
    }

    @Override
    public void relink(Hashtable<GraphElement,GraphElement> linkHash) {
        for(int i=0; i<inputVector.size(); ++i) {
            inputVector.set(i,(DataSource)linkHash.get(inputVector.get(i)));
        }
        spec.relink(linkHash);
    }
    
    public PlotSpec getPlotSpec() {
        return spec;
    }
    
    public void restoreFrame() {
        if(frameVisible) {
            showPlot();
        }
    }
    
    public PlotFrame getPlotFrame() {
    	return plotFrame;
    }
    
    public void frameAltered() {
        frameVisible=plotFrame.isVisible();
        if(frameVisible) {
            frameX=plotFrame.getX();
            frameY=plotFrame.getY();
            frameWidth=plotFrame.getWidth();
            frameHeight=plotFrame.getHeight();
        }
    }
    
    @Override
    public String toString() {
        return label.toString();
    }
    
    private void showPlot() {
    	new Thread(new Runnable() {
    		@Override
            public void run() {
		        if(plotFrame==null) {
		        	plotFrame=new PlotFrame(spec,Plot.this);
		        }
                if(!plotFrame.isVisible()) {
    		        plotFrame.setLocation(frameX,frameY);
    		        if(frameWidth>0) {
    		            plotFrame.setSize(frameWidth,frameHeight);
    		        }
    		        plotFrame.setVisible(true);
                } else {
                    spec.forceRedraw();
                    spec.fireRedraw();
                }
    		}
    	}).start();
    }

    private void treeSelectionChanged() {
        PlotObject selected=(PlotObject)tree.getLastSelectedPathComponent();
        if(selected!=null) {
			JComponent comp=selected.getPropertiesPanel();
			if(comp!=null) {
				poPropPanel.removeAll();
				poPropPanel.add(comp);
                poPropPanel.validate();
                poPropPanel.repaint();
			}
        }
    }

    private GraphLabelString label=new GraphLabelString(getDescription(),getPaint());
    private ArrayList<DataSource> inputVector;
    private PlotSpec spec;
    private boolean frameVisible;
    private int frameWidth,frameHeight;
    private int frameX,frameY;
    private transient PlotFrame plotFrame;
    private transient JTabbedPane propPanel;
    private transient JComponent poPropPanel;
    private transient JTree tree;
    private transient SourceInfoPanel sip;

    private static final long serialVersionUID=5876340897234l;
}