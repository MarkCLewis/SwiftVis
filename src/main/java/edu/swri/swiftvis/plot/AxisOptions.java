/* Generated by Together */

package edu.swri.swiftvis.plot;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.font.FontRenderContext;
import java.awt.font.LineMetrics;
import java.awt.geom.AffineTransform;
import java.awt.geom.Line2D;
import java.awt.geom.Rectangle2D;
import java.io.Serializable;
import java.util.ArrayList;

import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;

import edu.swri.swiftvis.DataSink;
import edu.swri.swiftvis.GraphicsTester;
import edu.swri.swiftvis.OptionsData;
import edu.swri.swiftvis.plot.util.FillOptions;
import edu.swri.swiftvis.plot.util.FillUser;
import edu.swri.swiftvis.plot.util.FontOptions;
import edu.swri.swiftvis.plot.util.FontUser;
import edu.swri.swiftvis.plot.util.FormattedString;
import edu.swri.swiftvis.plot.util.NumberFormatter;
import edu.swri.swiftvis.util.EditableBoolean;
import edu.swri.swiftvis.util.EditableDouble;
import edu.swri.swiftvis.util.EditableInt;
import edu.swri.swiftvis.util.EditableString;

/**
* This class puts all the options and drawing abilities for an axis in one
* place.  It is used by both the primary and secondary axis classes.
**/
public final class AxisOptions implements Serializable,FontUser,FillUser {
	public static void main(String[] args) {
		AxisOptions ao1=new AxisOptions(null);
        ao1.markStyle=11;
		AxisOptions ao2=new AxisOptions(null);
        ao2.markStyle=11;
        GraphicsTester gt=new GraphicsTester(1000,1000);
        AxisBounds ab1=ao1.getAxisBounds(1);
        AxisBounds ab2=ao2.getAxisBounds(1);
        Graphics2D g=(Graphics2D)gt.getImage().getGraphics();
        double w1=ab1.getOutside();
        double w2=ab2.getOutside();
        Rectangle2D plotBounds=new Rectangle2D.Double(w2,w1,990-2*w2,990-2*w1);
        ao1.drawAxis(g,plotBounds,ab1,HORIZONTAL_AXIS,0,1,true,1);
        ao2.drawAxis(g,plotBounds,ab2,VERTICAL_AXIS,0,1,true,1);
        gt.repaint();
    }

    public AxisOptions(AxisOptionUser aou) {
        this(aou,"Default");
    }
    
    public AxisOptions(AxisOptionUser aou,String name) {
        axisUser=aou;
        label=new FormattedString(name);
    }
    
    public AxisOptions(AxisOptions c,AxisOptionUser aou) {
        axisUser=aou;
        min=new EditableDouble(c.min.getValue());
        max=new EditableDouble(c.max.getValue());
        autoMin=new EditableBoolean(c.autoMin.getValue());
        autoMax=new EditableBoolean(c.autoMax.getValue());
        logScale=new EditableBoolean(c.logScale.getValue());
        markSpacing=new EditableDouble(c.markSpacing.getValue());
        minorTicks=new EditableInt(c.minorTicks.getValue());       
        autoMark=new EditableBoolean(c.autoMark.getValue());
        markStyle=c.markStyle;
        markLength=new EditableDouble(c.markLength.getValue());
        label=new FormattedString(c.label.getValue());
        showLabel=new EditableBoolean(c.showLabel.getValue());
        labelLocation=c.labelLocation;
        axisLocation=c.axisLocation;
        fontOptions=new FontOptions(this,c.fontOptions.getFont());
        fillOptions=new FillOptions(this,c.fillOptions.getColor());
        formatString=new EditableString(c.formatString.getValue());
    }

    @Override
    public String toString() { return "Axis - "+label.getValue(); }
    
    public void setDataPlots(ArrayList<? extends Bounded> data) {
        ArrayList<Integer> o=new ArrayList<Integer>();
        o.add(0);
        setDataPlots(data,o);
    }    

    /**
     * This tells the axis what data will be plotted with it.
     */
    public void setDataPlots(ArrayList<? extends Bounded> data,ArrayList<Integer> orientation) {
    	if(data==null) Thread.dumpStack();
        dataUsed=data;
        axisNum=orientation;
        setBounds();
    }

    public int getAxisLocation() {
        return axisLocation;
    }

    /**
     * Draws the axis in the bounds provided.  The bounds that are provided should
     * be for the plot area only.  It should not include the leading or trailing parts,
     * or the outside regions.
     * 
     * The current and total variables are used to decide if the labels for this
     * axis should really be drawn.
     * @param current This is the current count row or column for this axis.
     * @param total This is the total row or column count for this axis.
     * @param showMax This tells the routine whether to label the max tick mark.  Should be false if it adjoins.
     */
    public void drawAxis(Graphics2D g,Rectangle2D bounds,AxisBounds axisBounds,int dir,int current,
            int total,boolean showMax,float fontScale) {
        boolean doLabels=(axisLocation==MIN_SIDE && current==0)
            || (axisLocation==MAX_SIDE && current==total-1);
        double sideSign=(axisLocation==MIN_SIDE)?(1.0):(-1.0);
        g.setPaint(fillOptions.getColor());
        g.setFont(fontOptions.getFont(fontScale));
        // Draw the lines.
        if (dir==VERTICAL_AXIS) {
            double start=bounds.getMaxY();
            double end=bounds.getMinY();
            double center=(axisLocation==MIN_SIDE)?(bounds.getMinX()):(bounds.getMaxX());
            g.draw(new Line2D.Double(center,start,center,end));
            if ((markStyle & INNER_MARK)!=0 || (markStyle & OUTER_MARK)!=0
                || (markStyle & LABEL_MARK)!=0) {
                double x1=center,x2=center;
                if ((markStyle & OUTER_MARK)!=0) x1-=markLength.getValue()*sideSign*fontScale;
                if ((markStyle & INNER_MARK)!=0) x2+=markLength.getValue()*sideSign*fontScale;
                makeHorizontalMarks(g,start,end,x1,x2,center,(markStyle & LABEL_MARK)!=0 && doLabels,
                    showMax,fontScale);
            }
        } else {
            double start = bounds.getMinX();
            double end = bounds.getMaxX();
            double center=(axisLocation==MIN_SIDE)?(bounds.getMaxY()):(bounds.getMinY());
            g.draw(new Line2D.Double(start, center, end, center));
            if ((markStyle & INNER_MARK)!=0 || (markStyle & OUTER_MARK)!=0 || (markStyle & LABEL_MARK)!=0) {
                double y1=center,y2=center;
                if ((markStyle & OUTER_MARK)!=0) y1+=markLength.getValue()*sideSign*fontScale;
                if ((markStyle & INNER_MARK)!=0) y2-=markLength.getValue()*sideSign*fontScale;
                makeVerticalMarks(g,start,end,y1,y2,center,
                    (markStyle & LABEL_MARK)!=0 && doLabels,showMax,fontScale);
            }
        }
    }


    /**
     * This draws just a label for this axis.  This is done after the axis itself
     * is drawn so that it is possible to implement label sharing.  If I have
     * several of the same axis options next to one another they don't need to
     * be labeled differently.
     */
    public void drawAxisLabel(Graphics2D g,Rectangle2D bounds,AxisBounds axisBounds,int dir,float fontScale) {
    	if(!showLabel.getValue()) return;
		Rectangle2D strBnds=label.getBounds(fontOptions.getFont(fontScale),axisUser.getSink());
		double drawX,drawY;
		AffineTransform trans=null;
		if(dir==HORIZONTAL_AXIS) {
			drawX=bounds.getCenterX()-0.5*strBnds.getWidth();
			drawY=(axisLocation==MIN_SIDE)?bounds.getMaxY():bounds.getMinY();
			if(axisLocation==MIN_SIDE) {
				drawY+=axisBounds.getTextOffset()-strBnds.getMinY();			
			} else {
				drawY-=axisBounds.getTextOffset()+strBnds.getMaxY();			
			}
		} else {
			drawX=(axisLocation==MIN_SIDE)?bounds.getMinX():bounds.getMaxX();
			drawY=bounds.getCenterY()+0.5*strBnds.getWidth();
			if(axisLocation==MIN_SIDE) {
				drawX-=axisBounds.getTextOffset()+strBnds.getMaxY();			
			} else {
				drawX+=axisBounds.getTextOffset()-strBnds.getMinY();			
			}
			trans=g.getTransform();
			g.rotate(-Math.PI*0.5,(float)drawX,(float)drawY);
		}
		g.setPaint(Color.black);
		g.setFont(fontOptions.getFont(fontScale));
		label.draw(g,(float)drawX,(float)drawY,axisUser.getSink());
		if(dir==VERTICAL_AXIS) {
			g.setTransform(trans);
		}
    }
    
    /**
     * This returns the bounds for the entire area that the axis drawing will
     * cover.
     */
    public AxisBounds getAxisBounds(float fontScale) {
        double lead=0.0;
        double trail=0.0;
        double inside=0.0;
        double outside=0.0;
        double height=0.0;
        if((markStyle & INNER_MARK)!=0) inside=markLength.getValue()*fontScale;
        if((markStyle & OUTER_MARK)!=0) outside=markLength.getValue()*fontScale;
        if((markStyle & LABEL_MARK)!=0) {
            final double[] maxWH={0.0,0.0};
            final Font font=fontOptions.getFont(fontScale);
            doWorkOnMarks(new AxisMarkWorker() {
                @Override
                public void handleMark(double pos, FormattedString label,boolean minorMark) {
                    if(minorMark) return;
                    Rectangle2D strBnds=label.getBounds(font, null);//font.getStringBounds(label,frc);
                    if(strBnds.getWidth()>maxWH[0]) maxWH[0]=strBnds.getWidth();
                    if(strBnds.getHeight()>maxWH[1]) maxWH[1]=strBnds.getHeight();                    
                }
            });
            outside+=maxWH[0]+2;
            height=maxWH[1];
        }
        double textOffset=outside;
        if(showLabel.getValue()) {
			Rectangle2D strBnds=label.getBounds(fontOptions.getFont(fontScale),axisUser.getSink());
			if(labelLocation==MIN_SIDE) {
				lead=strBnds.getWidth();
				inside=Math.max(inside,strBnds.getHeight()/2+2);
				outside=Math.max(outside,strBnds.getHeight()/2+2);
			} else if(labelLocation==MAX_SIDE) {
				trail=strBnds.getWidth();
				inside=Math.max(inside,strBnds.getHeight()/2+2);
				outside=Math.max(outside,strBnds.getHeight()/2+2);
			} else {
                outside+=strBnds.getHeight()+2;
			}
        }
        return new AxisBounds(lead,trail,inside,outside,textOffset,height);
    }

    public double getMin() {
        return min.getValue();
    }

    public double getMax() {
        return max.getValue();
    }

    public JComponent getPropertiesPanel() {
        if(propPanel==null) {
            propPanel=new JPanel(new BorderLayout());
            Box box=new Box(BoxLayout.Y_AXIS);
            // Label
            JPanel outerPanel=new JPanel(new GridLayout(3,1));
            outerPanel.setBorder(BorderFactory.createTitledBorder("Label"));
            JPanel innerPanel=new JPanel(new BorderLayout());
            innerPanel.add(new JLabel("Text"),BorderLayout.WEST);
            innerPanel.add(label.getTextField(new FormattedString.Listener() {
                @Override
                public void valueChanged() {
                    axisUser.forceRedraw();
                    axisUser.fireRedraw();
                    axisUser.syncGUI();
                }
            }),BorderLayout.CENTER);
            outerPanel.add(innerPanel);
            // show label checkbox
            outerPanel.add(showLabel.getCheckBox("Show?",new EditableBoolean.Listener() {
                @Override
                public void valueChanged() {
                    axisUser.forceRedraw();
                    axisUser.fireRedraw();
                }
            }));
            // label location
            innerPanel=new JPanel(new BorderLayout());
            innerPanel.add(new JLabel("Location"),BorderLayout.WEST);
            final String[] labelLocs={"Middle","Minimum","Maximum"};
            final JComboBox labelLocBox=new JComboBox(labelLocs);
            labelLocBox.setSelectedIndex(labelLocation);
            labelLocBox.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    int loc=labelLocBox.getSelectedIndex();
                    if(loc==1) labelLocation=MIN_SIDE;
                    else if(loc==2) labelLocation=MAX_SIDE;
                    else labelLocation=MIDDLE;
                    axisUser.forceRedraw();
                    axisUser.fireRedraw();
                }
            } );
            innerPanel.add(labelLocBox,BorderLayout.CENTER);
            outerPanel.add(innerPanel);
            box.add(outerPanel);
            // min and max with auto
            outerPanel=new JPanel(new BorderLayout());
            outerPanel.setBorder(BorderFactory.createTitledBorder("Bounds"));
            JPanel autoPanel=new JPanel(new GridLayout(3,1));
            JPanel valuePanel=new JPanel(new GridLayout(3,1));
            autoPanel.add(new JLabel("Auto"));
            valuePanel.add(new JLabel("Value"));
            autoPanel.add(autoMin.getCheckBox("Min",new EditableBoolean.Listener() {
                @Override
                public void valueChanged() { autoMinAction(); }
            }));
            valuePanel.add(min.getTextField(new EditableDouble.Listener() {
                @Override
                public void valueChanged() { minChanged(); }
            }));
            autoPanel.add(autoMax.getCheckBox("Max",new EditableBoolean.Listener() {
                @Override
                public void valueChanged() { autoMaxAction(); }
            }));
            valuePanel.add(max.getTextField(new EditableDouble.Listener() {
                @Override
                public void valueChanged() { maxChanged(); }
            }));
            outerPanel.add(autoPanel,BorderLayout.WEST);
            outerPanel.add(valuePanel,BorderLayout.CENTER);
            box.add(outerPanel);
            // mark spacing and style
            outerPanel=new JPanel(new GridLayout(6,1));
            outerPanel.setBorder(BorderFactory.createTitledBorder("Tick Marks"));
            innerPanel=new JPanel(new BorderLayout());
            innerPanel.add(autoMark.getCheckBox("Auto",new EditableBoolean.Listener() {
                @Override
                public void valueChanged() { autoMarkSpacingAction(); }
            }),BorderLayout.WEST);
            innerPanel.add(markSpacing.getTextField(new EditableDouble.Listener() {
                @Override
                public void valueChanged() { markSpacingChanged(); }
            }),BorderLayout.CENTER);
            outerPanel.add(innerPanel);
            innerPanel=new JPanel(new BorderLayout());
            innerPanel.add(new JLabel("Label Formatter"),BorderLayout.WEST);
            innerPanel.add(formatString.getTextField(null),BorderLayout.CENTER);
            outerPanel.add(innerPanel);
            final JCheckBox innerMarkBox=new JCheckBox("Inner Mark");
            innerMarkBox.setSelected((markStyle&INNER_MARK)!=0);
			innerMarkBox.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    if(innerMarkBox.isSelected()) markStyle|=INNER_MARK;
                    else markStyle&=(~INNER_MARK);
                    axisUser.forceRedraw();
                    axisUser.fireRedraw();
                }
            } );
            outerPanel.add(innerMarkBox);
            final JCheckBox outerMarkBox=new JCheckBox("Outer Mark");
            outerMarkBox.setSelected((markStyle&OUTER_MARK)!=0);
			outerMarkBox.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    if(outerMarkBox.isSelected()) markStyle|=OUTER_MARK;
                    else markStyle&=(~OUTER_MARK);
                    axisUser.forceRedraw();
                    axisUser.fireRedraw();
                }
            } );
            outerPanel.add(outerMarkBox);
            final JCheckBox labelMarkBox=new JCheckBox("Label Marks");
            labelMarkBox.setSelected((markStyle&LABEL_MARK)!=0);
			labelMarkBox.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    if(labelMarkBox.isSelected()) markStyle|=LABEL_MARK;
                    else markStyle&=(~LABEL_MARK);
                    axisUser.forceRedraw();
                    axisUser.fireRedraw();
                }
            } );
            outerPanel.add(labelMarkBox);
            innerPanel=new JPanel(new BorderLayout());
            innerPanel.add(new JLabel("Minor Ticks"),BorderLayout.WEST);
            innerPanel.add(minorTicks.getTextField(new EditableInt.Listener() {
                @Override
                public void valueChanged() { minorTicksChanged(); }
            }),BorderLayout.CENTER);
            outerPanel.add(innerPanel);
            box.add(outerPanel);
            // others
            outerPanel=new JPanel(new GridLayout(4,1));
            outerPanel.setBorder(BorderFactory.createTitledBorder("Other Options"));
            // log scale
            outerPanel.add(logScale.getCheckBox("Log Scale",new EditableBoolean.Listener() {
                @Override
                public void valueChanged() { logScaleAction(); }                
            }));
            // axis location
            innerPanel=new JPanel(new BorderLayout());
            innerPanel.add(new JLabel("Axis Location"),BorderLayout.WEST);
            final String[] axisLocs={"Minimum","Maximum"};
            final JComboBox axisLocBox=new JComboBox(axisLocs);
            axisLocBox.setSelectedIndex(axisLocation-1);
            axisLocBox.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    int loc=axisLocBox.getSelectedIndex();
                    if(loc==0) axisLocation=MIN_SIDE;
                    else axisLocation=MAX_SIDE;
                    axisUser.forceRedraw();
                    axisUser.fireRedraw();
                }
            } );
            innerPanel.add(axisLocBox,BorderLayout.CENTER);
            outerPanel.add(innerPanel);
            // color
            JButton button=new JButton("Edit Color");
            button.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) { fillOptions.edit(); }
            } );
            outerPanel.add(button);
            // font
            button=new JButton("Edit Font");
            button.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) { fontOptions.edit(); }
            } );
            outerPanel.add(button);
            box.add(outerPanel);
            propPanel.add(box,BorderLayout.NORTH);
        }
        return propPanel;
    }
    
    public Font getFont() {
        return fontOptions.getFont();
    }
    
    public boolean isLogScale() {
        return logScale.getValue();
    }

    //-------------------------------------------------------------------------
    // From FontUser
    //-------------------------------------------------------------------------

    @Override
    public void applyFont(FontOptions fo) {
        axisUser.forceRedraw();
        axisUser.fireRedraw();
    }

    //-------------------------------------------------------------------------
    // From FillUser
    //-------------------------------------------------------------------------

    @Override
    public void applyFill(FillOptions fo) {
        axisUser.forceRedraw();
        axisUser.fireRedraw();
    }
    
    public boolean mergeLabelWith(AxisOptions ao) {
        return label.getValue().equals(ao.label.getValue()) && showLabel.getValue() && ao.showLabel.getValue();
    }

    private void setBounds() {
        if(!autoMin.getValue() && !autoMax.getValue() && !autoMark.getValue() || dataUsed.size()<1) return;
        double[] val=dataUsed.get(0).getBounds()[axisNum.get(0)];
        double testMin=val[0],testMax=val[1];
        for(int i=0; i<dataUsed.size(); ++i) {
            Bounded dps=dataUsed.get(i);
	        val=dps.getBounds()[axisNum.get(i)];
            if(val[0]<testMin) testMin=val[0];
            if(val[1]>testMax) testMax=val[1];
        }
        if(!autoMin.getValue()) testMin=min.getValue();
        if(!autoMax.getValue()) testMax=max.getValue();
        if(testMin==testMax) testMax+=1;
        double[] clean={testMin,testMax};
        double recMark=NumberFormatter.cleanBounds(clean);
        if(autoMin.getValue()) min.setValue(clean[0]);
        if(autoMax.getValue()) max.setValue(clean[1]);
        if(autoMark.getValue()) markSpacing.setValue(Math.abs(recMark));
        if(Math.abs(max.getValue()-min.getValue())/markSpacing.getValue()>1000) {
            markSpacing.setValue(recMark);
        }
        //axisUser.fireRedraw();  // This line causes lots to redraws.
    }
    
    private void doWorkOnMarks(AxisMarkWorker worker) {
        if(logScale.getValue()) {
            double pos=Math.floor(Math.log10(Math.min(min.getValue(),max.getValue())));
            pos=Math.pow(10,pos);
            while(pos<=Math.max(min.getValue(),max.getValue())) {
                if(pos>=Math.min(min.getValue(),max.getValue())) {
                    String label=NumberFormatter.format(formatString.getValue(), pos);
                    worker.handleMark(pos,new FormattedString(label),false);
                }
                for(int i=2; i<10; ++i) {
                    if(pos*i>=Math.min(min.getValue(),max.getValue()) && pos*i<=Math.max(min.getValue(),max.getValue()))
                        worker.handleMark(pos*i,null,true);
                }
                pos*=10;
            }
        } else {
            double pos;
            if(min.getValue()<=max.getValue()) {
                pos=Math.floor(min.getValue()/markSpacing.getValue())*markSpacing.getValue();
            } else {
                pos=Math.floor(max.getValue()/markSpacing.getValue())*markSpacing.getValue();
            }
            while(pos<=Math.max(max.getValue(),min.getValue())) {
                if(pos>=Math.min(min.getValue(),max.getValue())) {
                    double printPos=Math.round(pos/markSpacing.getValue())*markSpacing.getValue();
                    String label=NumberFormatter.format(formatString.getValue(), printPos);
                    worker.handleMark(printPos,new FormattedString(label),false);
                }
                for(int i=1; i<=minorTicks.getValue(); ++i) {
                    double mpos=pos+i*markSpacing.getValue()/(minorTicks.getValue()+1);
                    if(mpos>=Math.min(min.getValue(),max.getValue()) && mpos<=Math.max(min.getValue(),max.getValue()))
                        worker.handleMark(mpos,null,true);
                }
                pos+=markSpacing.getValue();
            }        
        }
    }
    
    private void makeHorizontalMarks(final Graphics2D g,final double start,final double end,final double x1,final double x2,final double xmid,final boolean writeLabel,final boolean showMax,final float fontScale) {
        final LineMetrics metrics=fontOptions.getFont(fontScale).getLineMetrics("1.0e5",frc);
        final PlotTransform trans=new PlotTransform(this,start,end);
        doWorkOnMarks(new AxisMarkWorker() {
            @Override
            public void handleMark(double ypos,FormattedString label,boolean minorMark) {
                double y=trans.transformX(ypos);//start+(ypos-min.getValue())*(end-start)/(max.getValue()-min.getValue());
                if(minorMark) {
                    double nx1=(x1+xmid)*0.5;
                    double nx2=(x2+xmid)*0.5;
                    g.draw(new Line2D.Double(nx1,y,nx2,y));
                } else {
                    g.draw(new Line2D.Double(x1,y,x2,y));
                    Rectangle2D labelBounds=label.getBounds(fontOptions.getFont(fontScale), null);
                    double diff=Math.abs(end-y);
                    if(writeLabel && (showMax || diff>labelBounds.getHeight()*0.5)) {
                        if(axisLocation==MIN_SIDE) {
                            label.draw(g, (float)(x1-labelBounds.getWidth()-1.0),(float)(y+labelBounds.getHeight()-metrics.getAscent()), null);
                        } else {
                            label.draw(g,(float)(x1+1.0),(float)(y+labelBounds.getHeight()-metrics.getAscent()),null);
                        }
                    }                
                }
            }
        });
    }

    private void makeVerticalMarks(final Graphics2D g,final double start,final double end,final double y1,final double y2,final double ymid,final boolean writeLabel,final boolean showMax,final float fontScale) {
        final LineMetrics metrics=fontOptions.getFont(fontScale).getLineMetrics("1.0e5",frc);
        final AffineTransform original=g.getTransform();
        final PlotTransform trans=new PlotTransform(this,start,end);
        doWorkOnMarks(new AxisMarkWorker() {
            @Override
            public void handleMark(double xpos,FormattedString label,boolean minorMark) {
                double x=trans.transformX(xpos);//start+(xpos-min.getValue())*(end-start)/(max.getValue()-min.getValue());
                if(minorMark) {
                    double ny1=(y1+ymid)*0.5;
                    double ny2=(y2+ymid)*0.5;
                    g.draw(new Line2D.Double(x,ny1,x,ny2));
                } else {
                    g.draw(new Line2D.Double(x,y1,x,y2));
                    Rectangle2D labelBounds=label.getBounds(fontOptions.getFont(fontScale),null);
                    double diff=Math.abs(end-x);
                    if(writeLabel && (showMax || diff>labelBounds.getHeight()*0.5)) {
                        if(axisLocation==MIN_SIDE) {
                            g.translate((x-labelBounds.getHeight()+metrics.getAscent()),y1+2.0);
                            g.rotate(Math.PI*0.5);
                            label.draw(g, 0, 0, null);
                        } else {
                            g.translate((x-labelBounds.getHeight()+metrics.getAscent()),y1-labelBounds.getWidth()-2.0);
                            g.rotate(Math.PI*0.5);
                            label.draw(g, 0, 0, null);
                        }
                        g.setTransform(original);
                    }
                }
            }
        });
    }
    
    private void autoMinAction() {
        if(autoMin.getValue()) setBounds();
    }

    private void minChanged() {
        if(min.getValue()<=0.0 && logScale.getValue()) {
            logScale.setValue(false);
        }
        autoMin.setValue(false);
        setBounds();
        axisUser.forceRedraw();
		axisUser.fireRedraw();
    }

    private void autoMaxAction() {
        if(autoMax.getValue()) setBounds();
    }

    private void maxChanged() {
        if(max.getValue()<=0.0 && logScale.getValue()) {
            logScale.setValue(false);
        }
        autoMax.setValue(false);
        setBounds();
		axisUser.forceRedraw();
		axisUser.fireRedraw();
    }

    private void autoMarkSpacingAction() {
        if(autoMark.getValue()) setBounds();
    }

    private void logScaleAction() {
        if(logScale.getValue() && (min.getValue()<=0.0 || max.getValue()<=0.0)) {
            JOptionPane.showMessageDialog(propPanel,"The plot range must be positive for a log scale.");
            logScale.setValue(false);
        } else {
            axisUser.forceRedraw();
            axisUser.fireRedraw();
        }
    }

    private void markSpacingChanged() {
        if(markSpacing.getValue()<=0.0) {
        	markSpacing.setValue(-1*markSpacing.getValue());
        }
        if(Math.abs(max.getValue()-min.getValue())/markSpacing.getValue()>1000) {
            JOptionPane.showMessageDialog(propPanel,"Warning: This value will draw many tick marks.");
        } else {
            autoMark.setValue(false);
            setBounds();
    		axisUser.forceRedraw();
    		axisUser.fireRedraw();
        }
    }

    private void minorTicksChanged() {
        axisUser.forceRedraw();
        axisUser.fireRedraw();
    }

    public static final int INNER_MARK=1;
    public static final int OUTER_MARK=2;
    public static final int LABEL_MARK=4;

    public static final int MIDDLE=0;
    public static final int MIN_SIDE=1;
    public static final int MAX_SIDE=2;

    public static final int VERTICAL_AXIS=0;
    public static final int HORIZONTAL_AXIS=1;

    private AxisOptionUser axisUser;
    private EditableDouble min = new EditableDouble(0.0);
    private EditableDouble max = new EditableDouble(10.0);
    private EditableBoolean autoMin = new EditableBoolean(true);
    private EditableBoolean autoMax = new EditableBoolean(true);
    private EditableBoolean logScale=new EditableBoolean(false);
    private EditableDouble markSpacing = new EditableDouble(1.0);
    private EditableInt minorTicks=new EditableInt(0);
    private EditableBoolean autoMark = new EditableBoolean(true);
    private int markStyle=INNER_MARK | OUTER_MARK | LABEL_MARK;  // Bitwise combination
    private EditableDouble markLength = new EditableDouble(10.0);
    private FormattedString label = new FormattedString("Default Label");
    private EditableBoolean showLabel = new EditableBoolean(false);
    private EditableString formatString=new EditableString("%1.2g");
    private int labelLocation=MIDDLE;  // min, max, or middle
    private int axisLocation = MIN_SIDE; // min side or max side.
    private FillOptions fillOptions = new FillOptions(this, Color.black);
    private FontOptions fontOptions = new FontOptions(this,OptionsData.instance().getAxisFont());
    private ArrayList<? extends Bounded> dataUsed;
    private ArrayList<Integer> axisNum;

    private static final FontRenderContext frc=new FontRenderContext(new AffineTransform(),true,true);

    private transient JPanel propPanel;

    private static final long serialVersionUID=356098271347l;
    
    public static class AxisBounds {
        public AxisBounds(double l,double t,double i,double o,double to,double h) {
            lead=l;
            trail=t;
            inside=i;
            outside=o;
            textOffset=to;
            height=h;
        }

        public double getLead() {
            return lead;
        }

        public double getTrail() {
            return trail;
        }

        public double getInside() {
            return inside;
        }

        public double getOutside() {
            return outside;
        }

        public double getTextOffset() {
            return textOffset;
        }

        public double getHeight() {
            return height;
        }

        private double lead;
        private double trail;
        private double inside;
        private double outside;
        private double textOffset;
        private double height;
    }
    
    public interface AxisOptionUser {
        void fireRedraw();
        void forceRedraw();
        void syncGUI();
        DataSink getSink();
    }
    
    private static interface AxisMarkWorker {
        void handleMark(double pos,FormattedString label,boolean minorMark);
    }
}
